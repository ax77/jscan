struct linked_s { struct linked_node_s *head; struct linked_node_s *tail; size_t count; }; struct linked_node_s { struct linked_s *owner; struct linked_node_s *next; struct linked_node_s *prev; int data; }; struct linked_iter_s { struct linked_s *target; struct linked_node_s *cursor; size_t index; bool start; bool end; }; typedef struct linked_s linked; typedef struct linked_node_s linked_node; typedef struct linked_iter_s linked_iter; static linked *ll_new(void); static void ll_free(linked *_list_); static bool ll_push_front(linked *_list_, int element); static bool ll_push(linked *_list_, int element, size_t index); static bool ll_push_back(linked *_list_, int element); static bool ll_pop_front(linked *_list_); static bool ll_pop(linked *_list_, size_t index); static bool ll_pop_back(linked *_list_); static bool ll_push_if(linked *_list_, int element, size_t index, bool condition); static bool ll_pop_if(linked *_list_, size_t index, bool condition); static int ll_back(linked *_list_); static int ll_get(linked *_list_, size_t index); static int ll_front(linked *_list_); static bool ll_empty(linked *_list_); static size_t ll_count(linked *_list_); static linked_node *ll_new_node(linked *_owner_, int element); static linked_node *ll_get_node(linked *_list_, size_t index); static bool ll_insert_nxt(linked_node *node, int element); static bool ll_insert_prv(linked_node *node, int element); static bool ll_remove_nxt(linked_node *node); static bool ll_remove_cur(linked_node *node); static bool ll_remove_prv(linked_node *node); static void ll_iter_new(linked_iter *iter, linked *target); static bool ll_iter_start(linked_iter *iter); static bool ll_iter_end(linked_iter *iter); static void ll_iter_tostart(linked_iter *iter); static void ll_iter_toend(linked_iter *iter); static bool ll_iter_next(linked_iter *iter, int *result, size_t *index); static bool ll_iter_prev(linked_iter *iter, int *result, size_t *index); static linked *ll_new(void) { linked *_list_ = malloc(sizeof(linked)); if (!_list_) return NULL; _list_->count = 0; _list_->head = NULL; _list_->tail = NULL; return _list_; } static void ll_free(linked *_list_) { linked_node *scan = _list_->head; while (_list_->head != NULL) { _list_->head = _list_->head->next; free(scan); scan = _list_->head; } free(_list_); } static bool ll_push_front(linked *_list_, int element) { linked_node *node = ll_new_node(_list_, element); if (!node) return false; if (ll_empty(_list_)) { _list_->head = node; _list_->tail = node; } else { node->next = _list_->head; _list_->head->prev = node; _list_->head = node; } _list_->count++; return true; } static bool ll_push(linked *_list_, int element, size_t index) { if (index > _list_->count) return false; if (index == 0) { return ll_push_front(_list_, element); } else if (index == _list_->count) { return ll_push_back(_list_, element); } linked_node *node = ll_new_node(_list_, element); if (!node) return false; linked_node *scan = ll_get_node(_list_, index - 1); node->next = scan->next; node->prev = scan; node->next->prev = node; node->prev->next = node; _list_->count++; return true; } static bool ll_push_back(linked *_list_, int element) { linked_node *node = ll_new_node(_list_, element); if (!node) return false; if (ll_empty(_list_)) { _list_->head = node; _list_->tail = node; } else { node->prev = _list_->tail; _list_->tail->next = node; _list_->tail = node; } _list_->count++; return true; } static bool ll_pop_front(linked *_list_) { if (ll_empty(_list_)) return false; linked_node *node = _list_->head; _list_->head = _list_->head->next; free(node); if (_list_->head == NULL) _list_->tail = NULL; else _list_->head->prev = NULL; _list_->count--; return true; } static bool ll_pop(linked *_list_, size_t index) { if (ll_empty(_list_)) return false; if (index == 0) { return ll_pop_front(_list_); } else if (index == _list_->count - 1) { return ll_pop_back(_list_); } linked_node *node = ll_get_node(_list_, index); if (!node) return false; node->next->prev = node->prev; node->prev->next = node->next; free(node); _list_->count--; return true; } static bool ll_pop_back(linked *_list_) { if (ll_empty(_list_)) return false; linked_node *node = _list_->tail; _list_->tail = _list_->tail->prev; free(node); if (_list_->tail == NULL) _list_->head = NULL; else _list_->tail->next = NULL; _list_->count--; return true; } static bool ll_push_if(linked *_list_, int element, size_t index, bool condition) { if (condition) return ll_push(_list_, element, index); return false; } static bool ll_pop_if(linked *_list_, size_t index, bool condition) { if (condition) return ll_pop(_list_, index); return false; } static int ll_front(linked *_list_) { if (ll_empty(_list_)) return 0; return _list_->head->data; } static int ll_get(linked *_list_, size_t index) { if (index >= _list_->count) return 0; if (ll_empty(_list_)) return 0; linked_node *scan = ll_get_node(_list_, index); if (scan == NULL) return 0; return scan->data; } static int ll_back(linked *_list_) { if (ll_empty(_list_)) return 0; return _list_->tail->data; } static bool ll_empty(linked *_list_) { return _list_->count == 0; } static size_t ll_count(linked *_list_) { return _list_->count; } static bool ll_insert_nxt(linked_node *node, int element) { linked_node *new_node = ll_new_node(node->owner, element); if (!new_node) return false; new_node->next = node->next; if (node->next != NULL) node->next->prev = new_node; else node->owner->tail = new_node; new_node->prev = node; node->next = new_node; node->owner->count++; return true; } static bool ll_insert_prv(linked_node *node, int element) { linked_node *new_node = ll_new_node(node->owner, element); if (!new_node) return false; new_node->prev = node->prev; if (node->prev != NULL) node->prev->next = new_node; else node->owner->head = new_node; new_node->next = node; node->prev = new_node; node->owner->count++; return true; } static bool ll_remove_nxt(linked_node *node) { if (node->next == NULL) return false; linked_node *tmp = node->next; if (node->next != NULL) { node->next = node->next->next; node->next->prev = node; } else node->owner->tail = node; node->owner->count--; free(tmp); return true; } static bool ll_remove_cur(linked_node *node) { if (node->prev != NULL) node->prev->next = node->next; else node->owner->head = node->next; if (node->next != NULL) node->next->prev = node->prev; else node->owner->tail = node->prev; node->owner->count--; free(node); return true; } static bool ll_remove_prv(linked_node *node) { if (node->prev == NULL) return false; linked_node *tmp = node->prev; if (node->prev != NULL) { node->prev = node->prev->prev; node->prev->next = node; } else node->owner->head = node; free(tmp); return true; } static linked_node *ll_new_node(linked *_owner_, int element) { linked_node *node = malloc(sizeof(linked_node)); if (!node) return NULL; node->owner = _owner_; node->data = element; node->next = NULL; node->prev = NULL; return node; } static linked_node *ll_get_node(linked *_list_, size_t index) { if (index >= _list_->count) return NULL; if (ll_empty(_list_)) return NULL; linked_node *scan = NULL; if (index <= _list_->count / 2) { scan = _list_->head; for (size_t i = 0; i < index; i++) { scan = scan->next; } } else { scan = _list_->tail; for (size_t i = _list_->count - 1; i > index; i--) { scan = scan->prev; } } return scan; } static void ll_iter_new(linked_iter *iter, linked *target) { iter->target = target; iter->cursor = target->head; iter->index = 0; iter->start = true; iter->end = ll_empty(target); } static bool ll_iter_start(linked_iter *iter) { return iter->cursor->prev == NULL && iter->start; } static bool ll_iter_end(linked_iter *iter) { return iter->cursor->next == NULL && iter->end; } static void ll_iter_tostart(linked_iter *iter) { iter->cursor = iter->target->head; iter->index = 0; iter->start = true; iter->end = false; } static void ll_iter_toend(linked_iter *iter) { iter->cursor = iter->target->tail; iter->index = iter->target->count - 1; iter->start = false; iter->end = true; } static bool ll_iter_next(linked_iter *iter, int *result, size_t *index) { if (iter->end) return false; *index = iter->index; *result = iter->cursor->data; iter->start = false; if (iter->cursor->next == NULL) iter->end = true; else { iter->cursor = iter->cursor->next; iter->index++; } return true; } static bool ll_iter_prev(linked_iter *iter, int *result, size_t *index) { if (iter->start) return false; *index = iter->index; *result = iter->cursor->data; iter->end = false; if (iter->cursor->prev == NULL) iter->start = true; else { iter->cursor = iter->cursor->prev; iter->index--; } return true; }
int main(int argc, char const *argv[])
{
    size_t i;
    int r;
    linked *ll = ll_new();
    for (int i = 0; i < 10; i++)
        ll_push_back(ll, i);
    linked_iter iter;
    ll_iter_new(&iter, ll);
    for (int j = 0; j < 4; j++)
    {
        while (ll_iter_next(&iter, &r, &i))
            printf("C[%2d] = %2d\n", i, r);
        printf("\n");
        while (ll_iter_prev(&iter, &r, &i))
            printf("C[%2d] = %2d\n", i, r);
        printf("\n\n");
    }
    for (ll_iter_tostart(&iter); !ll_iter_end(&iter); )
    {
        ll_iter_next(&iter, &r, &i);
        printf("LL[%2d] = %2d\n", i, r);
    }
    printf("\n");
    for (ll_iter_toend(&iter); !ll_iter_start(&iter); )
    {
        ll_iter_prev(&iter, &r, &i);
        printf("LL[%2d] = %2d\n", i, r);
    }
    ll_free(ll);
    return 0;
}
