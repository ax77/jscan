struct ignore_assign {
    ignore_assign(int value) : _value(value) { }
    operator int() const { return _value; }
    const ignore_assign& operator =(int dummy) {static_cast<void>(dummy); return *this; }
    int _value;
};
struct e_direction { enum _enumerated { none = 1, up = 0, right = 2, down = 4, left = 6 }; _enumerated _value; e_direction(_enumerated value) : _value(value) { } operator _enumerated() const { return _value; } _enumerated& operator=(_enumerated value) { return _value = value;} const char* _to_string() const { for (size_t index = 0; index < _count; ++index) { if (_values()[index] == _value) return _names()[index]; } return NULL; } static const size_t _count = 5; static const int* _values() { static const int values[] = { (ignore_assign)none = 1, (ignore_assign)up = 0, (ignore_assign)right = 2, (ignore_assign)down = 4, (ignore_assign)left = 6, }; return values; } static const char* const* _names() { static const char* const raw_names[] = { "none = 1", "up = 0", "right = 2", "down = 4", "left = 6", }; static char* processed_names[_count]; static bool initialized = false; if (!initialized) { for (size_t index = 0; index < _count; ++index) { size_t length = std::strcspn(raw_names[index], " =\t\n\r"); processed_names[index] = new char[length + 1]; std::strncpy( processed_names[index], raw_names[index], length); processed_names[index][length] = '\0'; } } return processed_names; } };
struct e_entity { enum _enumerated { empty = 0, wall, iron_wall, base,enemy, hero, bullet }; _enumerated _value; e_entity(_enumerated value) : _value(value) { } operator _enumerated() const { return _value; } _enumerated& operator=(_enumerated value) { return _value = value;} const char* _to_string() const { for (size_t index = 0; index < _count; ++index) { if (_values()[index] == _value) return _names()[index]; } return NULL; } static const size_t _count = 7; static const int* _values() { static const int values[] = { (ignore_assign)empty = 0, (ignore_assign)wall, (ignore_assign)iron_wall, (ignore_assign)base, (ignore_assign)enemy, (ignore_assign)hero, (ignore_assign)bullet, }; return values; } static const char* const* _names() { static const char* const raw_names[] = { "empty = 0", "wall", "iron_wall", "base", "enemy", "hero", "bullet", }; static char* processed_names[_count]; static bool initialized = false; if (!initialized) { for (size_t index = 0; index < _count; ++index) { size_t length = std::strcspn(raw_names[index], " =\t\n\r"); processed_names[index] = new char[length + 1]; std::strncpy( processed_names[index], raw_names[index], length); processed_names[index][length] = '\0'; } } return processed_names; } };
struct e_collision { enum _enumerated { static_entity = 0, dynamic_entity }; _enumerated _value; e_collision(_enumerated value) : _value(value) { } operator _enumerated() const { return _value; } _enumerated& operator=(_enumerated value) { return _value = value;} const char* _to_string() const { for (size_t index = 0; index < _count; ++index) { if (_values()[index] == _value) return _names()[index]; } return NULL; } static const size_t _count = 2; static const int* _values() { static const int values[] = { (ignore_assign)static_entity = 0, (ignore_assign)dynamic_entity, }; return values; } static const char* const* _names() { static const char* const raw_names[] = { "static_entity = 0", "dynamic_entity", }; static char* processed_names[_count]; static bool initialized = false; if (!initialized) { for (size_t index = 0; index < _count; ++index) { size_t length = std::strcspn(raw_names[index], " =\t\n\r"); processed_names[index] = new char[length + 1]; std::strncpy( processed_names[index], raw_names[index], length); processed_names[index][length] = '\0'; } } return processed_names; } };
