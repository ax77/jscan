typedef struct
{
    size_t hashIndex;
    size_t dataPrev;
    size_t dataIndex;
} FindResult;
typedef struct { size_t length; size_t capacity; size_t * data; } size_t_Array ; size_t_Array size_t_Array_Create(void); void size_t_Array_Free( size_t_Array* a ); size_t size_t_Array_Get( size_t_Array* a, size_t index); size_t* size_t_Array_GetPtr( size_t_Array* a, size_t index); void size_t_Array_Set( size_t_Array* a, size_t index, size_t value ); size_t size_t_Array_Append( size_t_Array* a, size_t item); size_t size_t_Array_AppendMany( size_t_Array* a, size_t * items, size_t count); void size_t_Array_PopBack( size_t_Array* a); size_t size_t_Array_Length( size_t_Array* a); size_t * size_t_Array_Begin( size_t_Array* a); size_t * size_t_Array_End( size_t_Array* a); size_t size_t_Array_Front( size_t_Array* a); size_t size_t_Array_Back( size_t_Array* a); void size_t_Array_Clear( size_t_Array* a); void size_t_Array_ShrinkToFit( size_t_Array* a); void size_t_Array_Resize( size_t_Array* a, size_t length); void size_t_Array_SetCapacity( size_t_Array* a, size_t capacity ); void size_t_Array_Reserve( size_t_Array* a, size_t capacity); void size_t_Array_Grow( size_t_Array* a, size_t minCapacity); inline size_t_Array size_t_Array_Create(void) { size_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void size_t_Array_Free( size_t_Array* a ) { free(a->data); } inline size_t size_t_Array_Get( size_t_Array* a, size_t index) { return a->data[index]; } inline size_t* size_t_Array_GetPtr( size_t_Array* a, size_t index) { return & (a->data[index]); } inline void size_t_Array_Set( size_t_Array* a, size_t index, size_t value ) { a->data[index] = value; } inline size_t size_t_Array_Append( size_t_Array* a, size_t item) { if (a->length + 1 > a->capacity) size_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t size_t_Array_AppendMany( size_t_Array* a, size_t * items, size_t count) { if (a->capacity <= a->length + count) size_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( size_t ) ); a->length += count; return a->length; }inline void size_t_Array_PopBack( size_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t size_t_Array_Length( size_t_Array* a) { return a->length; } inline size_t size_t_Array_Capacity(size_t_Array* a) { return a->capacity; } inline size_t * size_t_Array_Begin(size_t_Array* a) { return a->data; } inline size_t * size_t_Array_End(size_t_Array* a) { return a->data + a->length; } inline size_t size_t_Array_Front(size_t_Array* a) { assert(a->length > 0); return * ( size_t_Array_Begin(a) ); } inline size_t size_t_Array_Back(size_t_Array* a) { assert(a->length > 0); return * ( size_t_Array_End(a) - 1 ); } inline void size_t_Array_Clear(size_t_Array* a) { size_t_Array_Resize(a, 0); } inline void size_t_Array_ShrinkToFit(size_t_Array* a) { size_t_Array_SetCapacity(a, a->length); } inline void size_t_Array_Resize(size_t_Array* a, size_t length) { if (length > a->capacity) size_t_Array_Grow(a, length); a->length = length; } inline void size_t_Array_SetCapacity( size_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) size_t_Array_Resize(a, capacity); size_t * data = NULL; if (capacity > 0) { data = ( size_t * ) malloc( capacity * sizeof( size_t ) ); memcpy(data, a->data, a->length * sizeof( size_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void size_t_Array_Reserve( size_t_Array* a, size_t capacity) { if (capacity > a->capacity) size_t_Array_SetCapacity(a, capacity); } inline void size_t_Array_Grow( size_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; size_t_Array_SetCapacity(a, capacity); };
typedef size_t *Containment_Ptr_size_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_size_t * data; } Containment_Ptr_size_t_Array ; Containment_Ptr_size_t_Array Containment_Ptr_size_t_Array_Create(void); void Containment_Ptr_size_t_Array_Free( Containment_Ptr_size_t_Array* a ); Containment_Ptr_size_t Containment_Ptr_size_t_Array_Get( Containment_Ptr_size_t_Array* a, size_t index); Containment_Ptr_size_t* Containment_Ptr_size_t_Array_GetPtr( Containment_Ptr_size_t_Array* a, size_t index); void Containment_Ptr_size_t_Array_Set( Containment_Ptr_size_t_Array* a, size_t index, Containment_Ptr_size_t value ); size_t Containment_Ptr_size_t_Array_Append( Containment_Ptr_size_t_Array* a, Containment_Ptr_size_t item); size_t Containment_Ptr_size_t_Array_AppendMany( Containment_Ptr_size_t_Array* a, Containment_Ptr_size_t * items, size_t count); void Containment_Ptr_size_t_Array_PopBack( Containment_Ptr_size_t_Array* a); size_t Containment_Ptr_size_t_Array_Length( Containment_Ptr_size_t_Array* a); Containment_Ptr_size_t * Containment_Ptr_size_t_Array_Begin( Containment_Ptr_size_t_Array* a); Containment_Ptr_size_t * Containment_Ptr_size_t_Array_End( Containment_Ptr_size_t_Array* a); Containment_Ptr_size_t Containment_Ptr_size_t_Array_Front( Containment_Ptr_size_t_Array* a); Containment_Ptr_size_t Containment_Ptr_size_t_Array_Back( Containment_Ptr_size_t_Array* a); void Containment_Ptr_size_t_Array_Clear( Containment_Ptr_size_t_Array* a); void Containment_Ptr_size_t_Array_ShrinkToFit( Containment_Ptr_size_t_Array* a); void Containment_Ptr_size_t_Array_Resize( Containment_Ptr_size_t_Array* a, size_t length); void Containment_Ptr_size_t_Array_SetCapacity( Containment_Ptr_size_t_Array* a, size_t capacity ); void Containment_Ptr_size_t_Array_Reserve( Containment_Ptr_size_t_Array* a, size_t capacity); void Containment_Ptr_size_t_Array_Grow( Containment_Ptr_size_t_Array* a, size_t minCapacity); inline Containment_Ptr_size_t_Array Containment_Ptr_size_t_Array_Create(void) { Containment_Ptr_size_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_size_t_Array_Free( Containment_Ptr_size_t_Array* a ) { free(a->data); } inline Containment_Ptr_size_t Containment_Ptr_size_t_Array_Get( Containment_Ptr_size_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_size_t* Containment_Ptr_size_t_Array_GetPtr( Containment_Ptr_size_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_size_t_Array_Set( Containment_Ptr_size_t_Array* a, size_t index, Containment_Ptr_size_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_size_t_Array_Append( Containment_Ptr_size_t_Array* a, Containment_Ptr_size_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_size_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_size_t_Array_AppendMany( Containment_Ptr_size_t_Array* a, Containment_Ptr_size_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_size_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_size_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_size_t_Array_PopBack( Containment_Ptr_size_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_size_t_Array_Length( Containment_Ptr_size_t_Array* a) { return a->length; } inline size_t Containment_Ptr_size_t_Array_Capacity(Containment_Ptr_size_t_Array* a) { return a->capacity; } inline Containment_Ptr_size_t * Containment_Ptr_size_t_Array_Begin(Containment_Ptr_size_t_Array* a) { return a->data; } inline Containment_Ptr_size_t * Containment_Ptr_size_t_Array_End(Containment_Ptr_size_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_size_t Containment_Ptr_size_t_Array_Front(Containment_Ptr_size_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_size_t_Array_Begin(a) ); } inline Containment_Ptr_size_t Containment_Ptr_size_t_Array_Back(Containment_Ptr_size_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_size_t_Array_End(a) - 1 ); } inline void Containment_Ptr_size_t_Array_Clear(Containment_Ptr_size_t_Array* a) { Containment_Ptr_size_t_Array_Resize(a, 0); } inline void Containment_Ptr_size_t_Array_ShrinkToFit(Containment_Ptr_size_t_Array* a) { Containment_Ptr_size_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_size_t_Array_Resize(Containment_Ptr_size_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_size_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_size_t_Array_SetCapacity( Containment_Ptr_size_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_size_t_Array_Resize(a, capacity); Containment_Ptr_size_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_size_t * ) malloc( capacity * sizeof( Containment_Ptr_size_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_size_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_size_t_Array_Reserve( Containment_Ptr_size_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_size_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_size_t_Array_Grow( Containment_Ptr_size_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_size_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; size_t value; } size_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; size_t_Hashmap_Entry * data; } size_t_Hashmap_Entry_Array ; size_t_Hashmap_Entry_Array size_t_Hashmap_Entry_Array_Create(void); void size_t_Hashmap_Entry_Array_Free( size_t_Hashmap_Entry_Array* a ); size_t_Hashmap_Entry size_t_Hashmap_Entry_Array_Get( size_t_Hashmap_Entry_Array* a, size_t index); size_t_Hashmap_Entry* size_t_Hashmap_Entry_Array_GetPtr( size_t_Hashmap_Entry_Array* a, size_t index); void size_t_Hashmap_Entry_Array_Set( size_t_Hashmap_Entry_Array* a, size_t index, size_t_Hashmap_Entry value ); size_t size_t_Hashmap_Entry_Array_Append( size_t_Hashmap_Entry_Array* a, size_t_Hashmap_Entry item); size_t size_t_Hashmap_Entry_Array_AppendMany( size_t_Hashmap_Entry_Array* a, size_t_Hashmap_Entry * items, size_t count); void size_t_Hashmap_Entry_Array_PopBack( size_t_Hashmap_Entry_Array* a); size_t size_t_Hashmap_Entry_Array_Length( size_t_Hashmap_Entry_Array* a); size_t_Hashmap_Entry * size_t_Hashmap_Entry_Array_Begin( size_t_Hashmap_Entry_Array* a); size_t_Hashmap_Entry * size_t_Hashmap_Entry_Array_End( size_t_Hashmap_Entry_Array* a); size_t_Hashmap_Entry size_t_Hashmap_Entry_Array_Front( size_t_Hashmap_Entry_Array* a); size_t_Hashmap_Entry size_t_Hashmap_Entry_Array_Back( size_t_Hashmap_Entry_Array* a); void size_t_Hashmap_Entry_Array_Clear( size_t_Hashmap_Entry_Array* a); void size_t_Hashmap_Entry_Array_ShrinkToFit( size_t_Hashmap_Entry_Array* a); void size_t_Hashmap_Entry_Array_Resize( size_t_Hashmap_Entry_Array* a, size_t length); void size_t_Hashmap_Entry_Array_SetCapacity( size_t_Hashmap_Entry_Array* a, size_t capacity ); void size_t_Hashmap_Entry_Array_Reserve( size_t_Hashmap_Entry_Array* a, size_t capacity); void size_t_Hashmap_Entry_Array_Grow( size_t_Hashmap_Entry_Array* a, size_t minCapacity); inline size_t_Hashmap_Entry_Array size_t_Hashmap_Entry_Array_Create(void) { size_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void size_t_Hashmap_Entry_Array_Free( size_t_Hashmap_Entry_Array* a ) { free(a->data); } inline size_t_Hashmap_Entry size_t_Hashmap_Entry_Array_Get( size_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline size_t_Hashmap_Entry* size_t_Hashmap_Entry_Array_GetPtr( size_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void size_t_Hashmap_Entry_Array_Set( size_t_Hashmap_Entry_Array* a, size_t index, size_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t size_t_Hashmap_Entry_Array_Append( size_t_Hashmap_Entry_Array* a, size_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) size_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t size_t_Hashmap_Entry_Array_AppendMany( size_t_Hashmap_Entry_Array* a, size_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) size_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( size_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void size_t_Hashmap_Entry_Array_PopBack( size_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t size_t_Hashmap_Entry_Array_Length( size_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t size_t_Hashmap_Entry_Array_Capacity(size_t_Hashmap_Entry_Array* a) { return a->capacity; } inline size_t_Hashmap_Entry * size_t_Hashmap_Entry_Array_Begin(size_t_Hashmap_Entry_Array* a) { return a->data; } inline size_t_Hashmap_Entry * size_t_Hashmap_Entry_Array_End(size_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline size_t_Hashmap_Entry size_t_Hashmap_Entry_Array_Front(size_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( size_t_Hashmap_Entry_Array_Begin(a) ); } inline size_t_Hashmap_Entry size_t_Hashmap_Entry_Array_Back(size_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( size_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void size_t_Hashmap_Entry_Array_Clear(size_t_Hashmap_Entry_Array* a) { size_t_Hashmap_Entry_Array_Resize(a, 0); } inline void size_t_Hashmap_Entry_Array_ShrinkToFit(size_t_Hashmap_Entry_Array* a) { size_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void size_t_Hashmap_Entry_Array_Resize(size_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) size_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void size_t_Hashmap_Entry_Array_SetCapacity( size_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) size_t_Hashmap_Entry_Array_Resize(a, capacity); size_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( size_t_Hashmap_Entry * ) malloc( capacity * sizeof( size_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( size_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void size_t_Hashmap_Entry_Array_Reserve( size_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) size_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void size_t_Hashmap_Entry_Array_Grow( size_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; size_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; size_t_Hashmap_Entry_Array data; } size_t_Hashmap; size_t_Hashmap size_t_Hashmap_Create(void); void size_t_Hashmap_Free( size_t_Hashmap* h); size_t size_t_Hashmap_Impl_AddEntry( size_t_Hashmap* h, uint64_t key); void size_t_Hashmap_Impl_Erase( size_t_Hashmap* h, FindResult* fr); FindResult size_t_Hashmap_Impl_FindByKey( size_t_Hashmap* h, uint64_t key); FindResult size_t_Hashmap_Impl_FindByEntry( size_t_Hashmap* h, size_t_Hashmap_Entry* e); size_t size_t_Hashmap_Impl_Make( size_t_Hashmap* h, uint64_t key); void size_t_Hashmap_Impl_FindAndErase(size_t_Hashmap* h, uint64_t key); size_t size_t_Hashmap_Impl_FindOrFail(size_t_Hashmap* h, uint64_t key); size_t size_t_Hashmap_Impl_FindOrMake( size_t_Hashmap* h, uint64_t key); void size_t_Hashmap_Impl_Rehash( size_t_Hashmap* h, size_t newCapacity); void size_t_Hashmap_Impl_Grow( size_t_Hashmap* h); char size_t_Hashmap_Impl_Full( size_t_Hashmap* h); char size_t_Hashmap_Has( size_t_Hashmap* h, uint64_t key); size_t size_t_Hashmap_Get( size_t_Hashmap* h, uint64_t key, size_t defaultValue ); size_t * size_t_Hashmap_GetPtr( size_t_Hashmap* h, uint64_t key, size_t * defaultValue ); size_t size_t_Hashmap_Set( size_t_Hashmap* h, uint64_t key, size_t value ); size_t size_t_Hashmap_SetPtr( size_t_Hashmap* h, uint64_t key, size_t* value ); void size_t_Hashmap_Remove( size_t_Hashmap* h, uint64_t key ); void size_t_Hashmap_Reserve( size_t_Hashmap* h, size_t capacity ); void size_t_Hashmap_Clear( size_t_Hashmap* h ); void size_t_Hashmap_Multi_Get( size_t_Hashmap* h, uint64_t key, size_t_Array * items ); void size_t_Hashmap_Multi_GetPtrs( size_t_Hashmap* h, uint64_t key, Containment_Ptr_size_t_Array * items ); size_t size_t_Hashmap_Multi_Count( size_t_Hashmap* h, uint64_t key ); void size_t_Hashmap_Multi_Insert( size_t_Hashmap* h, uint64_t key, size_t value ); void size_t_Hashmap_Multi_InsertMany( size_t_Hashmap* h, uint64_t key, size_t * values, size_t count ); size_t_Hashmap_Entry* size_t_Hashmap_Multi_FindFirst( size_t_Hashmap* h, uint64_t key); size_t_Hashmap_Entry* size_t_Hashmap_Multi_FindNext( size_t_Hashmap* h, size_t_Hashmap_Entry* e); void size_t_Hashmap_Multi_Remove( size_t_Hashmap* h, size_t_Hashmap_Entry* e); void size_t_Hashmap_Multi_RemoveAll(size_t_Hashmap* h, uint64_t key); inline size_t_Hashmap size_t_Hashmap_Create(void) { size_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = size_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void size_t_Hashmap_Free( size_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); size_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t size_t_Hashmap_Impl_AddEntry( size_t_Hashmap* h, uint64_t key) { size_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; size_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void size_t_Hashmap_Impl_Erase( size_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; size_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = size_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult size_t_Hashmap_Impl_FindByKey( size_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult size_t_Hashmap_Impl_FindByEntry( size_t_Hashmap* h, size_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t size_t_Hashmap_Impl_Make( size_t_Hashmap* h, uint64_t key) { FindResult fr = size_t_Hashmap_Impl_FindByKey(h, key); size_t index = size_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void size_t_Hashmap_Impl_FindAndErase( size_t_Hashmap* h, uint64_t key) { FindResult fr = size_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) size_t_Hashmap_Impl_Erase(h, &fr); } inline size_t size_t_Hashmap_Impl_FindOrFail( size_t_Hashmap* h, uint64_t key) { return size_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t size_t_Hashmap_Impl_FindOrMake( size_t_Hashmap* h, uint64_t key) { FindResult fr = size_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = size_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void size_t_Hashmap_Impl_Rehash( size_t_Hashmap* h, size_t newCapacity) { size_t_Hashmap nh = size_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; size_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { size_t_Hashmap_Entry* e = &h->data.data[i]; size_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = size_t_Hashmap_Create(); } inline void size_t_Hashmap_Impl_Grow( size_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; size_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char size_t_Hashmap_Impl_Full( size_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char size_t_Hashmap_Has( size_t_Hashmap* h, uint64_t key) { return size_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline size_t size_t_Hashmap_Get( size_t_Hashmap* h, uint64_t key, size_t defaultValue ) { size_t index = size_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline size_t * size_t_Hashmap_GetPtr( size_t_Hashmap* h, uint64_t key, size_t * defaultValue ) { size_t index = size_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t size_t_Hashmap_Set( size_t_Hashmap* h, uint64_t key, size_t value ) { if (h->hashes.length == 0) size_t_Hashmap_Impl_Grow(h); size_t index = size_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (size_t_Hashmap_Impl_Full(h)) size_t_Hashmap_Impl_Grow(h); return index; } inline size_t size_t_Hashmap_SetPtr( size_t_Hashmap* h, uint64_t key, size_t* value ) { if (h->hashes.length == 0) size_t_Hashmap_Impl_Grow(h); size_t index = size_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (size_t_Hashmap_Impl_Full(h)) size_t_Hashmap_Impl_Grow(h); return index; } inline void size_t_Hashmap_Remove( size_t_Hashmap* h, uint64_t key ) { size_t_Hashmap_Impl_FindAndErase(h, key); } inline void size_t_Hashmap_Reserve( size_t_Hashmap* h, size_t capacity ) { size_t_Hashmap_Impl_Rehash(h, capacity); } inline void size_t_Hashmap_Clear( size_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); size_t_Hashmap_Entry_Array_Clear(&h->data); } inline void size_t_Hashmap_Multi_Get( size_t_Hashmap* h, uint64_t key, size_t_Array * items ) { size_t_Hashmap_Entry* e = size_t_Hashmap_Multi_FindFirst(h, key); while (e) { size_t_Array_Append(items, e->value); e = size_t_Hashmap_Multi_FindNext(h, e); } } inline void size_t_Hashmap_Multi_GetPtrs( size_t_Hashmap* h, uint64_t key, Containment_Ptr_size_t_Array * items ) { size_t_Hashmap_Entry* e = size_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_size_t_Array_Append(items, & (e->value) ); e = size_t_Hashmap_Multi_FindNext(h, e); } } inline size_t size_t_Hashmap_Multi_Count( size_t_Hashmap* h, uint64_t key ) { size_t_Hashmap_Entry* e = size_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = size_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void size_t_Hashmap_Multi_Insert( size_t_Hashmap* h, uint64_t key, size_t value ) { if (h->hashes.length == 0) size_t_Hashmap_Impl_Grow(h); size_t next = size_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (size_t_Hashmap_Impl_Full(h)) size_t_Hashmap_Impl_Grow(h); } inline void size_t_Hashmap_Multi_InsertMany( size_t_Hashmap* h, uint64_t key, size_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { size_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline size_t_Hashmap_Entry* size_t_Hashmap_Multi_FindFirst( size_t_Hashmap* h, uint64_t key) { size_t index = size_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline size_t_Hashmap_Entry* size_t_Hashmap_Multi_FindNext( size_t_Hashmap* h, size_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void size_t_Hashmap_Multi_Remove( size_t_Hashmap* h, size_t_Hashmap_Entry* e) { FindResult fr = size_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) size_t_Hashmap_Impl_Erase(h, &fr); } inline void size_t_Hashmap_Multi_RemoveAll(size_t_Hashmap* h, uint64_t key) { while (size_t_Hashmap_Has(h, key)) size_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; char * data; } char_Array ; char_Array char_Array_Create(void); void char_Array_Free( char_Array* a ); char char_Array_Get( char_Array* a, size_t index); char* char_Array_GetPtr( char_Array* a, size_t index); void char_Array_Set( char_Array* a, size_t index, char value ); size_t char_Array_Append( char_Array* a, char item); size_t char_Array_AppendMany( char_Array* a, char * items, size_t count); void char_Array_PopBack( char_Array* a); size_t char_Array_Length( char_Array* a); char * char_Array_Begin( char_Array* a); char * char_Array_End( char_Array* a); char char_Array_Front( char_Array* a); char char_Array_Back( char_Array* a); void char_Array_Clear( char_Array* a); void char_Array_ShrinkToFit( char_Array* a); void char_Array_Resize( char_Array* a, size_t length); void char_Array_SetCapacity( char_Array* a, size_t capacity ); void char_Array_Reserve( char_Array* a, size_t capacity); void char_Array_Grow( char_Array* a, size_t minCapacity); inline char_Array char_Array_Create(void) { char_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void char_Array_Free( char_Array* a ) { free(a->data); } inline char char_Array_Get( char_Array* a, size_t index) { return a->data[index]; } inline char* char_Array_GetPtr( char_Array* a, size_t index) { return & (a->data[index]); } inline void char_Array_Set( char_Array* a, size_t index, char value ) { a->data[index] = value; } inline size_t char_Array_Append( char_Array* a, char item) { if (a->length + 1 > a->capacity) char_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t char_Array_AppendMany( char_Array* a, char * items, size_t count) { if (a->capacity <= a->length + count) char_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( char ) ); a->length += count; return a->length; }inline void char_Array_PopBack( char_Array* a) { assert(a->length > 0); a->length--; } inline size_t char_Array_Length( char_Array* a) { return a->length; } inline size_t char_Array_Capacity(char_Array* a) { return a->capacity; } inline char * char_Array_Begin(char_Array* a) { return a->data; } inline char * char_Array_End(char_Array* a) { return a->data + a->length; } inline char char_Array_Front(char_Array* a) { assert(a->length > 0); return * ( char_Array_Begin(a) ); } inline char char_Array_Back(char_Array* a) { assert(a->length > 0); return * ( char_Array_End(a) - 1 ); } inline void char_Array_Clear(char_Array* a) { char_Array_Resize(a, 0); } inline void char_Array_ShrinkToFit(char_Array* a) { char_Array_SetCapacity(a, a->length); } inline void char_Array_Resize(char_Array* a, size_t length) { if (length > a->capacity) char_Array_Grow(a, length); a->length = length; } inline void char_Array_SetCapacity( char_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) char_Array_Resize(a, capacity); char * data = NULL; if (capacity > 0) { data = ( char * ) malloc( capacity * sizeof( char ) ); memcpy(data, a->data, a->length * sizeof( char ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void char_Array_Reserve( char_Array* a, size_t capacity) { if (capacity > a->capacity) char_Array_SetCapacity(a, capacity); } inline void char_Array_Grow( char_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; char_Array_SetCapacity(a, capacity); } typedef char *Containment_Ptr_char ; typedef struct { size_t length; size_t capacity; Containment_Ptr_char * data; } Containment_Ptr_char_Array ; Containment_Ptr_char_Array Containment_Ptr_char_Array_Create(void); void Containment_Ptr_char_Array_Free( Containment_Ptr_char_Array* a ); Containment_Ptr_char Containment_Ptr_char_Array_Get( Containment_Ptr_char_Array* a, size_t index); Containment_Ptr_char* Containment_Ptr_char_Array_GetPtr( Containment_Ptr_char_Array* a, size_t index); void Containment_Ptr_char_Array_Set( Containment_Ptr_char_Array* a, size_t index, Containment_Ptr_char value ); size_t Containment_Ptr_char_Array_Append( Containment_Ptr_char_Array* a, Containment_Ptr_char item); size_t Containment_Ptr_char_Array_AppendMany( Containment_Ptr_char_Array* a, Containment_Ptr_char * items, size_t count); void Containment_Ptr_char_Array_PopBack( Containment_Ptr_char_Array* a); size_t Containment_Ptr_char_Array_Length( Containment_Ptr_char_Array* a); Containment_Ptr_char * Containment_Ptr_char_Array_Begin( Containment_Ptr_char_Array* a); Containment_Ptr_char * Containment_Ptr_char_Array_End( Containment_Ptr_char_Array* a); Containment_Ptr_char Containment_Ptr_char_Array_Front( Containment_Ptr_char_Array* a); Containment_Ptr_char Containment_Ptr_char_Array_Back( Containment_Ptr_char_Array* a); void Containment_Ptr_char_Array_Clear( Containment_Ptr_char_Array* a); void Containment_Ptr_char_Array_ShrinkToFit( Containment_Ptr_char_Array* a); void Containment_Ptr_char_Array_Resize( Containment_Ptr_char_Array* a, size_t length); void Containment_Ptr_char_Array_SetCapacity( Containment_Ptr_char_Array* a, size_t capacity ); void Containment_Ptr_char_Array_Reserve( Containment_Ptr_char_Array* a, size_t capacity); void Containment_Ptr_char_Array_Grow( Containment_Ptr_char_Array* a, size_t minCapacity); inline Containment_Ptr_char_Array Containment_Ptr_char_Array_Create(void) { Containment_Ptr_char_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_char_Array_Free( Containment_Ptr_char_Array* a ) { free(a->data); } inline Containment_Ptr_char Containment_Ptr_char_Array_Get( Containment_Ptr_char_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_char* Containment_Ptr_char_Array_GetPtr( Containment_Ptr_char_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_char_Array_Set( Containment_Ptr_char_Array* a, size_t index, Containment_Ptr_char value ) { a->data[index] = value; } inline size_t Containment_Ptr_char_Array_Append( Containment_Ptr_char_Array* a, Containment_Ptr_char item) { if (a->length + 1 > a->capacity) Containment_Ptr_char_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_char_Array_AppendMany( Containment_Ptr_char_Array* a, Containment_Ptr_char * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_char_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_char ) ); a->length += count; return a->length; }inline void Containment_Ptr_char_Array_PopBack( Containment_Ptr_char_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_char_Array_Length( Containment_Ptr_char_Array* a) { return a->length; } inline size_t Containment_Ptr_char_Array_Capacity(Containment_Ptr_char_Array* a) { return a->capacity; } inline Containment_Ptr_char * Containment_Ptr_char_Array_Begin(Containment_Ptr_char_Array* a) { return a->data; } inline Containment_Ptr_char * Containment_Ptr_char_Array_End(Containment_Ptr_char_Array* a) { return a->data + a->length; } inline Containment_Ptr_char Containment_Ptr_char_Array_Front(Containment_Ptr_char_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_char_Array_Begin(a) ); } inline Containment_Ptr_char Containment_Ptr_char_Array_Back(Containment_Ptr_char_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_char_Array_End(a) - 1 ); } inline void Containment_Ptr_char_Array_Clear(Containment_Ptr_char_Array* a) { Containment_Ptr_char_Array_Resize(a, 0); } inline void Containment_Ptr_char_Array_ShrinkToFit(Containment_Ptr_char_Array* a) { Containment_Ptr_char_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_char_Array_Resize(Containment_Ptr_char_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_char_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_char_Array_SetCapacity( Containment_Ptr_char_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_char_Array_Resize(a, capacity); Containment_Ptr_char * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_char * ) malloc( capacity * sizeof( Containment_Ptr_char ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_char ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_char_Array_Reserve( Containment_Ptr_char_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_char_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_char_Array_Grow( Containment_Ptr_char_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_char_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; char value; } char_Hashmap_Entry; typedef struct { size_t length; size_t capacity; char_Hashmap_Entry * data; } char_Hashmap_Entry_Array ; char_Hashmap_Entry_Array char_Hashmap_Entry_Array_Create(void); void char_Hashmap_Entry_Array_Free( char_Hashmap_Entry_Array* a ); char_Hashmap_Entry char_Hashmap_Entry_Array_Get( char_Hashmap_Entry_Array* a, size_t index); char_Hashmap_Entry* char_Hashmap_Entry_Array_GetPtr( char_Hashmap_Entry_Array* a, size_t index); void char_Hashmap_Entry_Array_Set( char_Hashmap_Entry_Array* a, size_t index, char_Hashmap_Entry value ); size_t char_Hashmap_Entry_Array_Append( char_Hashmap_Entry_Array* a, char_Hashmap_Entry item); size_t char_Hashmap_Entry_Array_AppendMany( char_Hashmap_Entry_Array* a, char_Hashmap_Entry * items, size_t count); void char_Hashmap_Entry_Array_PopBack( char_Hashmap_Entry_Array* a); size_t char_Hashmap_Entry_Array_Length( char_Hashmap_Entry_Array* a); char_Hashmap_Entry * char_Hashmap_Entry_Array_Begin( char_Hashmap_Entry_Array* a); char_Hashmap_Entry * char_Hashmap_Entry_Array_End( char_Hashmap_Entry_Array* a); char_Hashmap_Entry char_Hashmap_Entry_Array_Front( char_Hashmap_Entry_Array* a); char_Hashmap_Entry char_Hashmap_Entry_Array_Back( char_Hashmap_Entry_Array* a); void char_Hashmap_Entry_Array_Clear( char_Hashmap_Entry_Array* a); void char_Hashmap_Entry_Array_ShrinkToFit( char_Hashmap_Entry_Array* a); void char_Hashmap_Entry_Array_Resize( char_Hashmap_Entry_Array* a, size_t length); void char_Hashmap_Entry_Array_SetCapacity( char_Hashmap_Entry_Array* a, size_t capacity ); void char_Hashmap_Entry_Array_Reserve( char_Hashmap_Entry_Array* a, size_t capacity); void char_Hashmap_Entry_Array_Grow( char_Hashmap_Entry_Array* a, size_t minCapacity); inline char_Hashmap_Entry_Array char_Hashmap_Entry_Array_Create(void) { char_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void char_Hashmap_Entry_Array_Free( char_Hashmap_Entry_Array* a ) { free(a->data); } inline char_Hashmap_Entry char_Hashmap_Entry_Array_Get( char_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline char_Hashmap_Entry* char_Hashmap_Entry_Array_GetPtr( char_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void char_Hashmap_Entry_Array_Set( char_Hashmap_Entry_Array* a, size_t index, char_Hashmap_Entry value ) { a->data[index] = value; } inline size_t char_Hashmap_Entry_Array_Append( char_Hashmap_Entry_Array* a, char_Hashmap_Entry item) { if (a->length + 1 > a->capacity) char_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t char_Hashmap_Entry_Array_AppendMany( char_Hashmap_Entry_Array* a, char_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) char_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( char_Hashmap_Entry ) ); a->length += count; return a->length; }inline void char_Hashmap_Entry_Array_PopBack( char_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t char_Hashmap_Entry_Array_Length( char_Hashmap_Entry_Array* a) { return a->length; } inline size_t char_Hashmap_Entry_Array_Capacity(char_Hashmap_Entry_Array* a) { return a->capacity; } inline char_Hashmap_Entry * char_Hashmap_Entry_Array_Begin(char_Hashmap_Entry_Array* a) { return a->data; } inline char_Hashmap_Entry * char_Hashmap_Entry_Array_End(char_Hashmap_Entry_Array* a) { return a->data + a->length; } inline char_Hashmap_Entry char_Hashmap_Entry_Array_Front(char_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( char_Hashmap_Entry_Array_Begin(a) ); } inline char_Hashmap_Entry char_Hashmap_Entry_Array_Back(char_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( char_Hashmap_Entry_Array_End(a) - 1 ); } inline void char_Hashmap_Entry_Array_Clear(char_Hashmap_Entry_Array* a) { char_Hashmap_Entry_Array_Resize(a, 0); } inline void char_Hashmap_Entry_Array_ShrinkToFit(char_Hashmap_Entry_Array* a) { char_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void char_Hashmap_Entry_Array_Resize(char_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) char_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void char_Hashmap_Entry_Array_SetCapacity( char_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) char_Hashmap_Entry_Array_Resize(a, capacity); char_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( char_Hashmap_Entry * ) malloc( capacity * sizeof( char_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( char_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void char_Hashmap_Entry_Array_Reserve( char_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) char_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void char_Hashmap_Entry_Array_Grow( char_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; char_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; char_Hashmap_Entry_Array data; } char_Hashmap; char_Hashmap char_Hashmap_Create(void); void char_Hashmap_Free( char_Hashmap* h); size_t char_Hashmap_Impl_AddEntry( char_Hashmap* h, uint64_t key); void char_Hashmap_Impl_Erase( char_Hashmap* h, FindResult* fr); FindResult char_Hashmap_Impl_FindByKey( char_Hashmap* h, uint64_t key); FindResult char_Hashmap_Impl_FindByEntry( char_Hashmap* h, char_Hashmap_Entry* e); size_t char_Hashmap_Impl_Make( char_Hashmap* h, uint64_t key); void char_Hashmap_Impl_FindAndErase(char_Hashmap* h, uint64_t key); size_t char_Hashmap_Impl_FindOrFail(char_Hashmap* h, uint64_t key); size_t char_Hashmap_Impl_FindOrMake( char_Hashmap* h, uint64_t key); void char_Hashmap_Impl_Rehash( char_Hashmap* h, size_t newCapacity); void char_Hashmap_Impl_Grow( char_Hashmap* h); char char_Hashmap_Impl_Full( char_Hashmap* h); char char_Hashmap_Has( char_Hashmap* h, uint64_t key); char char_Hashmap_Get( char_Hashmap* h, uint64_t key, char defaultValue ); char * char_Hashmap_GetPtr( char_Hashmap* h, uint64_t key, char * defaultValue ); size_t char_Hashmap_Set( char_Hashmap* h, uint64_t key, char value ); size_t char_Hashmap_SetPtr( char_Hashmap* h, uint64_t key, char* value ); void char_Hashmap_Remove( char_Hashmap* h, uint64_t key ); void char_Hashmap_Reserve( char_Hashmap* h, size_t capacity ); void char_Hashmap_Clear( char_Hashmap* h ); void char_Hashmap_Multi_Get( char_Hashmap* h, uint64_t key, char_Array * items ); void char_Hashmap_Multi_GetPtrs( char_Hashmap* h, uint64_t key, Containment_Ptr_char_Array * items ); size_t char_Hashmap_Multi_Count( char_Hashmap* h, uint64_t key ); void char_Hashmap_Multi_Insert( char_Hashmap* h, uint64_t key, char value ); void char_Hashmap_Multi_InsertMany( char_Hashmap* h, uint64_t key, char * values, size_t count ); char_Hashmap_Entry* char_Hashmap_Multi_FindFirst( char_Hashmap* h, uint64_t key); char_Hashmap_Entry* char_Hashmap_Multi_FindNext( char_Hashmap* h, char_Hashmap_Entry* e); void char_Hashmap_Multi_Remove( char_Hashmap* h, char_Hashmap_Entry* e); void char_Hashmap_Multi_RemoveAll(char_Hashmap* h, uint64_t key); inline char_Hashmap char_Hashmap_Create(void) { char_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = char_Hashmap_Entry_Array_Create(); return hashmap; } inline void char_Hashmap_Free( char_Hashmap* h ) { size_t_Array_Free(&h->hashes); char_Hashmap_Entry_Array_Free(&h->data); } inline size_t char_Hashmap_Impl_AddEntry( char_Hashmap* h, uint64_t key) { char_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; char_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void char_Hashmap_Impl_Erase( char_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; char_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = char_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult char_Hashmap_Impl_FindByKey( char_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult char_Hashmap_Impl_FindByEntry( char_Hashmap* h, char_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t char_Hashmap_Impl_Make( char_Hashmap* h, uint64_t key) { FindResult fr = char_Hashmap_Impl_FindByKey(h, key); size_t index = char_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void char_Hashmap_Impl_FindAndErase( char_Hashmap* h, uint64_t key) { FindResult fr = char_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) char_Hashmap_Impl_Erase(h, &fr); } inline size_t char_Hashmap_Impl_FindOrFail( char_Hashmap* h, uint64_t key) { return char_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t char_Hashmap_Impl_FindOrMake( char_Hashmap* h, uint64_t key) { FindResult fr = char_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = char_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void char_Hashmap_Impl_Rehash( char_Hashmap* h, size_t newCapacity) { char_Hashmap nh = char_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; char_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { char_Hashmap_Entry* e = &h->data.data[i]; char_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = char_Hashmap_Create(); } inline void char_Hashmap_Impl_Grow( char_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; char_Hashmap_Impl_Rehash(h, newCapacity); } inline char char_Hashmap_Impl_Full( char_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char char_Hashmap_Has( char_Hashmap* h, uint64_t key) { return char_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline char char_Hashmap_Get( char_Hashmap* h, uint64_t key, char defaultValue ) { size_t index = char_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline char * char_Hashmap_GetPtr( char_Hashmap* h, uint64_t key, char * defaultValue ) { size_t index = char_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t char_Hashmap_Set( char_Hashmap* h, uint64_t key, char value ) { if (h->hashes.length == 0) char_Hashmap_Impl_Grow(h); size_t index = char_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (char_Hashmap_Impl_Full(h)) char_Hashmap_Impl_Grow(h); return index; } inline size_t char_Hashmap_SetPtr( char_Hashmap* h, uint64_t key, char* value ) { if (h->hashes.length == 0) char_Hashmap_Impl_Grow(h); size_t index = char_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (char_Hashmap_Impl_Full(h)) char_Hashmap_Impl_Grow(h); return index; } inline void char_Hashmap_Remove( char_Hashmap* h, uint64_t key ) { char_Hashmap_Impl_FindAndErase(h, key); } inline void char_Hashmap_Reserve( char_Hashmap* h, size_t capacity ) { char_Hashmap_Impl_Rehash(h, capacity); } inline void char_Hashmap_Clear( char_Hashmap* h ) { size_t_Array_Clear(&h->hashes); char_Hashmap_Entry_Array_Clear(&h->data); } inline void char_Hashmap_Multi_Get( char_Hashmap* h, uint64_t key, char_Array * items ) { char_Hashmap_Entry* e = char_Hashmap_Multi_FindFirst(h, key); while (e) { char_Array_Append(items, e->value); e = char_Hashmap_Multi_FindNext(h, e); } } inline void char_Hashmap_Multi_GetPtrs( char_Hashmap* h, uint64_t key, Containment_Ptr_char_Array * items ) { char_Hashmap_Entry* e = char_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_char_Array_Append(items, & (e->value) ); e = char_Hashmap_Multi_FindNext(h, e); } } inline size_t char_Hashmap_Multi_Count( char_Hashmap* h, uint64_t key ) { char_Hashmap_Entry* e = char_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = char_Hashmap_Multi_FindNext(h, e); } return c; } inline void char_Hashmap_Multi_Insert( char_Hashmap* h, uint64_t key, char value ) { if (h->hashes.length == 0) char_Hashmap_Impl_Grow(h); size_t next = char_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (char_Hashmap_Impl_Full(h)) char_Hashmap_Impl_Grow(h); } inline void char_Hashmap_Multi_InsertMany( char_Hashmap* h, uint64_t key, char * values, size_t count ) { for (size_t i = 0; i < count; i++) { char_Hashmap_Multi_Insert(h, key, values[i]); } } inline char_Hashmap_Entry* char_Hashmap_Multi_FindFirst( char_Hashmap* h, uint64_t key) { size_t index = char_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline char_Hashmap_Entry* char_Hashmap_Multi_FindNext( char_Hashmap* h, char_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void char_Hashmap_Multi_Remove( char_Hashmap* h, char_Hashmap_Entry* e) { FindResult fr = char_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) char_Hashmap_Impl_Erase(h, &fr); } inline void char_Hashmap_Multi_RemoveAll(char_Hashmap* h, uint64_t key) { while (char_Hashmap_Has(h, key)) char_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; int8_t * data; } int8_t_Array ; int8_t_Array int8_t_Array_Create(void); void int8_t_Array_Free( int8_t_Array* a ); int8_t int8_t_Array_Get( int8_t_Array* a, size_t index); int8_t* int8_t_Array_GetPtr( int8_t_Array* a, size_t index); void int8_t_Array_Set( int8_t_Array* a, size_t index, int8_t value ); size_t int8_t_Array_Append( int8_t_Array* a, int8_t item); size_t int8_t_Array_AppendMany( int8_t_Array* a, int8_t * items, size_t count); void int8_t_Array_PopBack( int8_t_Array* a); size_t int8_t_Array_Length( int8_t_Array* a); int8_t * int8_t_Array_Begin( int8_t_Array* a); int8_t * int8_t_Array_End( int8_t_Array* a); int8_t int8_t_Array_Front( int8_t_Array* a); int8_t int8_t_Array_Back( int8_t_Array* a); void int8_t_Array_Clear( int8_t_Array* a); void int8_t_Array_ShrinkToFit( int8_t_Array* a); void int8_t_Array_Resize( int8_t_Array* a, size_t length); void int8_t_Array_SetCapacity( int8_t_Array* a, size_t capacity ); void int8_t_Array_Reserve( int8_t_Array* a, size_t capacity); void int8_t_Array_Grow( int8_t_Array* a, size_t minCapacity); inline int8_t_Array int8_t_Array_Create(void) { int8_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int8_t_Array_Free( int8_t_Array* a ) { free(a->data); } inline int8_t int8_t_Array_Get( int8_t_Array* a, size_t index) { return a->data[index]; } inline int8_t* int8_t_Array_GetPtr( int8_t_Array* a, size_t index) { return & (a->data[index]); } inline void int8_t_Array_Set( int8_t_Array* a, size_t index, int8_t value ) { a->data[index] = value; } inline size_t int8_t_Array_Append( int8_t_Array* a, int8_t item) { if (a->length + 1 > a->capacity) int8_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int8_t_Array_AppendMany( int8_t_Array* a, int8_t * items, size_t count) { if (a->capacity <= a->length + count) int8_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int8_t ) ); a->length += count; return a->length; }inline void int8_t_Array_PopBack( int8_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t int8_t_Array_Length( int8_t_Array* a) { return a->length; } inline size_t int8_t_Array_Capacity(int8_t_Array* a) { return a->capacity; } inline int8_t * int8_t_Array_Begin(int8_t_Array* a) { return a->data; } inline int8_t * int8_t_Array_End(int8_t_Array* a) { return a->data + a->length; } inline int8_t int8_t_Array_Front(int8_t_Array* a) { assert(a->length > 0); return * ( int8_t_Array_Begin(a) ); } inline int8_t int8_t_Array_Back(int8_t_Array* a) { assert(a->length > 0); return * ( int8_t_Array_End(a) - 1 ); } inline void int8_t_Array_Clear(int8_t_Array* a) { int8_t_Array_Resize(a, 0); } inline void int8_t_Array_ShrinkToFit(int8_t_Array* a) { int8_t_Array_SetCapacity(a, a->length); } inline void int8_t_Array_Resize(int8_t_Array* a, size_t length) { if (length > a->capacity) int8_t_Array_Grow(a, length); a->length = length; } inline void int8_t_Array_SetCapacity( int8_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int8_t_Array_Resize(a, capacity); int8_t * data = NULL; if (capacity > 0) { data = ( int8_t * ) malloc( capacity * sizeof( int8_t ) ); memcpy(data, a->data, a->length * sizeof( int8_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int8_t_Array_Reserve( int8_t_Array* a, size_t capacity) { if (capacity > a->capacity) int8_t_Array_SetCapacity(a, capacity); } inline void int8_t_Array_Grow( int8_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int8_t_Array_SetCapacity(a, capacity); } typedef int8_t *Containment_Ptr_int8_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_int8_t * data; } Containment_Ptr_int8_t_Array ; Containment_Ptr_int8_t_Array Containment_Ptr_int8_t_Array_Create(void); void Containment_Ptr_int8_t_Array_Free( Containment_Ptr_int8_t_Array* a ); Containment_Ptr_int8_t Containment_Ptr_int8_t_Array_Get( Containment_Ptr_int8_t_Array* a, size_t index); Containment_Ptr_int8_t* Containment_Ptr_int8_t_Array_GetPtr( Containment_Ptr_int8_t_Array* a, size_t index); void Containment_Ptr_int8_t_Array_Set( Containment_Ptr_int8_t_Array* a, size_t index, Containment_Ptr_int8_t value ); size_t Containment_Ptr_int8_t_Array_Append( Containment_Ptr_int8_t_Array* a, Containment_Ptr_int8_t item); size_t Containment_Ptr_int8_t_Array_AppendMany( Containment_Ptr_int8_t_Array* a, Containment_Ptr_int8_t * items, size_t count); void Containment_Ptr_int8_t_Array_PopBack( Containment_Ptr_int8_t_Array* a); size_t Containment_Ptr_int8_t_Array_Length( Containment_Ptr_int8_t_Array* a); Containment_Ptr_int8_t * Containment_Ptr_int8_t_Array_Begin( Containment_Ptr_int8_t_Array* a); Containment_Ptr_int8_t * Containment_Ptr_int8_t_Array_End( Containment_Ptr_int8_t_Array* a); Containment_Ptr_int8_t Containment_Ptr_int8_t_Array_Front( Containment_Ptr_int8_t_Array* a); Containment_Ptr_int8_t Containment_Ptr_int8_t_Array_Back( Containment_Ptr_int8_t_Array* a); void Containment_Ptr_int8_t_Array_Clear( Containment_Ptr_int8_t_Array* a); void Containment_Ptr_int8_t_Array_ShrinkToFit( Containment_Ptr_int8_t_Array* a); void Containment_Ptr_int8_t_Array_Resize( Containment_Ptr_int8_t_Array* a, size_t length); void Containment_Ptr_int8_t_Array_SetCapacity( Containment_Ptr_int8_t_Array* a, size_t capacity ); void Containment_Ptr_int8_t_Array_Reserve( Containment_Ptr_int8_t_Array* a, size_t capacity); void Containment_Ptr_int8_t_Array_Grow( Containment_Ptr_int8_t_Array* a, size_t minCapacity); inline Containment_Ptr_int8_t_Array Containment_Ptr_int8_t_Array_Create(void) { Containment_Ptr_int8_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_int8_t_Array_Free( Containment_Ptr_int8_t_Array* a ) { free(a->data); } inline Containment_Ptr_int8_t Containment_Ptr_int8_t_Array_Get( Containment_Ptr_int8_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_int8_t* Containment_Ptr_int8_t_Array_GetPtr( Containment_Ptr_int8_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_int8_t_Array_Set( Containment_Ptr_int8_t_Array* a, size_t index, Containment_Ptr_int8_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_int8_t_Array_Append( Containment_Ptr_int8_t_Array* a, Containment_Ptr_int8_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_int8_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_int8_t_Array_AppendMany( Containment_Ptr_int8_t_Array* a, Containment_Ptr_int8_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_int8_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_int8_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_int8_t_Array_PopBack( Containment_Ptr_int8_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_int8_t_Array_Length( Containment_Ptr_int8_t_Array* a) { return a->length; } inline size_t Containment_Ptr_int8_t_Array_Capacity(Containment_Ptr_int8_t_Array* a) { return a->capacity; } inline Containment_Ptr_int8_t * Containment_Ptr_int8_t_Array_Begin(Containment_Ptr_int8_t_Array* a) { return a->data; } inline Containment_Ptr_int8_t * Containment_Ptr_int8_t_Array_End(Containment_Ptr_int8_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_int8_t Containment_Ptr_int8_t_Array_Front(Containment_Ptr_int8_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int8_t_Array_Begin(a) ); } inline Containment_Ptr_int8_t Containment_Ptr_int8_t_Array_Back(Containment_Ptr_int8_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int8_t_Array_End(a) - 1 ); } inline void Containment_Ptr_int8_t_Array_Clear(Containment_Ptr_int8_t_Array* a) { Containment_Ptr_int8_t_Array_Resize(a, 0); } inline void Containment_Ptr_int8_t_Array_ShrinkToFit(Containment_Ptr_int8_t_Array* a) { Containment_Ptr_int8_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_int8_t_Array_Resize(Containment_Ptr_int8_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_int8_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_int8_t_Array_SetCapacity( Containment_Ptr_int8_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_int8_t_Array_Resize(a, capacity); Containment_Ptr_int8_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_int8_t * ) malloc( capacity * sizeof( Containment_Ptr_int8_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_int8_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_int8_t_Array_Reserve( Containment_Ptr_int8_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_int8_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_int8_t_Array_Grow( Containment_Ptr_int8_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_int8_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; int8_t value; } int8_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; int8_t_Hashmap_Entry * data; } int8_t_Hashmap_Entry_Array ; int8_t_Hashmap_Entry_Array int8_t_Hashmap_Entry_Array_Create(void); void int8_t_Hashmap_Entry_Array_Free( int8_t_Hashmap_Entry_Array* a ); int8_t_Hashmap_Entry int8_t_Hashmap_Entry_Array_Get( int8_t_Hashmap_Entry_Array* a, size_t index); int8_t_Hashmap_Entry* int8_t_Hashmap_Entry_Array_GetPtr( int8_t_Hashmap_Entry_Array* a, size_t index); void int8_t_Hashmap_Entry_Array_Set( int8_t_Hashmap_Entry_Array* a, size_t index, int8_t_Hashmap_Entry value ); size_t int8_t_Hashmap_Entry_Array_Append( int8_t_Hashmap_Entry_Array* a, int8_t_Hashmap_Entry item); size_t int8_t_Hashmap_Entry_Array_AppendMany( int8_t_Hashmap_Entry_Array* a, int8_t_Hashmap_Entry * items, size_t count); void int8_t_Hashmap_Entry_Array_PopBack( int8_t_Hashmap_Entry_Array* a); size_t int8_t_Hashmap_Entry_Array_Length( int8_t_Hashmap_Entry_Array* a); int8_t_Hashmap_Entry * int8_t_Hashmap_Entry_Array_Begin( int8_t_Hashmap_Entry_Array* a); int8_t_Hashmap_Entry * int8_t_Hashmap_Entry_Array_End( int8_t_Hashmap_Entry_Array* a); int8_t_Hashmap_Entry int8_t_Hashmap_Entry_Array_Front( int8_t_Hashmap_Entry_Array* a); int8_t_Hashmap_Entry int8_t_Hashmap_Entry_Array_Back( int8_t_Hashmap_Entry_Array* a); void int8_t_Hashmap_Entry_Array_Clear( int8_t_Hashmap_Entry_Array* a); void int8_t_Hashmap_Entry_Array_ShrinkToFit( int8_t_Hashmap_Entry_Array* a); void int8_t_Hashmap_Entry_Array_Resize( int8_t_Hashmap_Entry_Array* a, size_t length); void int8_t_Hashmap_Entry_Array_SetCapacity( int8_t_Hashmap_Entry_Array* a, size_t capacity ); void int8_t_Hashmap_Entry_Array_Reserve( int8_t_Hashmap_Entry_Array* a, size_t capacity); void int8_t_Hashmap_Entry_Array_Grow( int8_t_Hashmap_Entry_Array* a, size_t minCapacity); inline int8_t_Hashmap_Entry_Array int8_t_Hashmap_Entry_Array_Create(void) { int8_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int8_t_Hashmap_Entry_Array_Free( int8_t_Hashmap_Entry_Array* a ) { free(a->data); } inline int8_t_Hashmap_Entry int8_t_Hashmap_Entry_Array_Get( int8_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline int8_t_Hashmap_Entry* int8_t_Hashmap_Entry_Array_GetPtr( int8_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void int8_t_Hashmap_Entry_Array_Set( int8_t_Hashmap_Entry_Array* a, size_t index, int8_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t int8_t_Hashmap_Entry_Array_Append( int8_t_Hashmap_Entry_Array* a, int8_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) int8_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int8_t_Hashmap_Entry_Array_AppendMany( int8_t_Hashmap_Entry_Array* a, int8_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) int8_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int8_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void int8_t_Hashmap_Entry_Array_PopBack( int8_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t int8_t_Hashmap_Entry_Array_Length( int8_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t int8_t_Hashmap_Entry_Array_Capacity(int8_t_Hashmap_Entry_Array* a) { return a->capacity; } inline int8_t_Hashmap_Entry * int8_t_Hashmap_Entry_Array_Begin(int8_t_Hashmap_Entry_Array* a) { return a->data; } inline int8_t_Hashmap_Entry * int8_t_Hashmap_Entry_Array_End(int8_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline int8_t_Hashmap_Entry int8_t_Hashmap_Entry_Array_Front(int8_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int8_t_Hashmap_Entry_Array_Begin(a) ); } inline int8_t_Hashmap_Entry int8_t_Hashmap_Entry_Array_Back(int8_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int8_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void int8_t_Hashmap_Entry_Array_Clear(int8_t_Hashmap_Entry_Array* a) { int8_t_Hashmap_Entry_Array_Resize(a, 0); } inline void int8_t_Hashmap_Entry_Array_ShrinkToFit(int8_t_Hashmap_Entry_Array* a) { int8_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void int8_t_Hashmap_Entry_Array_Resize(int8_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) int8_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void int8_t_Hashmap_Entry_Array_SetCapacity( int8_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int8_t_Hashmap_Entry_Array_Resize(a, capacity); int8_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( int8_t_Hashmap_Entry * ) malloc( capacity * sizeof( int8_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( int8_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int8_t_Hashmap_Entry_Array_Reserve( int8_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) int8_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void int8_t_Hashmap_Entry_Array_Grow( int8_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int8_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; int8_t_Hashmap_Entry_Array data; } int8_t_Hashmap; int8_t_Hashmap int8_t_Hashmap_Create(void); void int8_t_Hashmap_Free( int8_t_Hashmap* h); size_t int8_t_Hashmap_Impl_AddEntry( int8_t_Hashmap* h, uint64_t key); void int8_t_Hashmap_Impl_Erase( int8_t_Hashmap* h, FindResult* fr); FindResult int8_t_Hashmap_Impl_FindByKey( int8_t_Hashmap* h, uint64_t key); FindResult int8_t_Hashmap_Impl_FindByEntry( int8_t_Hashmap* h, int8_t_Hashmap_Entry* e); size_t int8_t_Hashmap_Impl_Make( int8_t_Hashmap* h, uint64_t key); void int8_t_Hashmap_Impl_FindAndErase(int8_t_Hashmap* h, uint64_t key); size_t int8_t_Hashmap_Impl_FindOrFail(int8_t_Hashmap* h, uint64_t key); size_t int8_t_Hashmap_Impl_FindOrMake( int8_t_Hashmap* h, uint64_t key); void int8_t_Hashmap_Impl_Rehash( int8_t_Hashmap* h, size_t newCapacity); void int8_t_Hashmap_Impl_Grow( int8_t_Hashmap* h); char int8_t_Hashmap_Impl_Full( int8_t_Hashmap* h); char int8_t_Hashmap_Has( int8_t_Hashmap* h, uint64_t key); int8_t int8_t_Hashmap_Get( int8_t_Hashmap* h, uint64_t key, int8_t defaultValue ); int8_t * int8_t_Hashmap_GetPtr( int8_t_Hashmap* h, uint64_t key, int8_t * defaultValue ); size_t int8_t_Hashmap_Set( int8_t_Hashmap* h, uint64_t key, int8_t value ); size_t int8_t_Hashmap_SetPtr( int8_t_Hashmap* h, uint64_t key, int8_t* value ); void int8_t_Hashmap_Remove( int8_t_Hashmap* h, uint64_t key ); void int8_t_Hashmap_Reserve( int8_t_Hashmap* h, size_t capacity ); void int8_t_Hashmap_Clear( int8_t_Hashmap* h ); void int8_t_Hashmap_Multi_Get( int8_t_Hashmap* h, uint64_t key, int8_t_Array * items ); void int8_t_Hashmap_Multi_GetPtrs( int8_t_Hashmap* h, uint64_t key, Containment_Ptr_int8_t_Array * items ); size_t int8_t_Hashmap_Multi_Count( int8_t_Hashmap* h, uint64_t key ); void int8_t_Hashmap_Multi_Insert( int8_t_Hashmap* h, uint64_t key, int8_t value ); void int8_t_Hashmap_Multi_InsertMany( int8_t_Hashmap* h, uint64_t key, int8_t * values, size_t count ); int8_t_Hashmap_Entry* int8_t_Hashmap_Multi_FindFirst( int8_t_Hashmap* h, uint64_t key); int8_t_Hashmap_Entry* int8_t_Hashmap_Multi_FindNext( int8_t_Hashmap* h, int8_t_Hashmap_Entry* e); void int8_t_Hashmap_Multi_Remove( int8_t_Hashmap* h, int8_t_Hashmap_Entry* e); void int8_t_Hashmap_Multi_RemoveAll(int8_t_Hashmap* h, uint64_t key); inline int8_t_Hashmap int8_t_Hashmap_Create(void) { int8_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = int8_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void int8_t_Hashmap_Free( int8_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); int8_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t int8_t_Hashmap_Impl_AddEntry( int8_t_Hashmap* h, uint64_t key) { int8_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; int8_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void int8_t_Hashmap_Impl_Erase( int8_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; int8_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = int8_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult int8_t_Hashmap_Impl_FindByKey( int8_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult int8_t_Hashmap_Impl_FindByEntry( int8_t_Hashmap* h, int8_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t int8_t_Hashmap_Impl_Make( int8_t_Hashmap* h, uint64_t key) { FindResult fr = int8_t_Hashmap_Impl_FindByKey(h, key); size_t index = int8_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void int8_t_Hashmap_Impl_FindAndErase( int8_t_Hashmap* h, uint64_t key) { FindResult fr = int8_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) int8_t_Hashmap_Impl_Erase(h, &fr); } inline size_t int8_t_Hashmap_Impl_FindOrFail( int8_t_Hashmap* h, uint64_t key) { return int8_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t int8_t_Hashmap_Impl_FindOrMake( int8_t_Hashmap* h, uint64_t key) { FindResult fr = int8_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = int8_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void int8_t_Hashmap_Impl_Rehash( int8_t_Hashmap* h, size_t newCapacity) { int8_t_Hashmap nh = int8_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; int8_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { int8_t_Hashmap_Entry* e = &h->data.data[i]; int8_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = int8_t_Hashmap_Create(); } inline void int8_t_Hashmap_Impl_Grow( int8_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; int8_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char int8_t_Hashmap_Impl_Full( int8_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char int8_t_Hashmap_Has( int8_t_Hashmap* h, uint64_t key) { return int8_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline int8_t int8_t_Hashmap_Get( int8_t_Hashmap* h, uint64_t key, int8_t defaultValue ) { size_t index = int8_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline int8_t * int8_t_Hashmap_GetPtr( int8_t_Hashmap* h, uint64_t key, int8_t * defaultValue ) { size_t index = int8_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t int8_t_Hashmap_Set( int8_t_Hashmap* h, uint64_t key, int8_t value ) { if (h->hashes.length == 0) int8_t_Hashmap_Impl_Grow(h); size_t index = int8_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (int8_t_Hashmap_Impl_Full(h)) int8_t_Hashmap_Impl_Grow(h); return index; } inline size_t int8_t_Hashmap_SetPtr( int8_t_Hashmap* h, uint64_t key, int8_t* value ) { if (h->hashes.length == 0) int8_t_Hashmap_Impl_Grow(h); size_t index = int8_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (int8_t_Hashmap_Impl_Full(h)) int8_t_Hashmap_Impl_Grow(h); return index; } inline void int8_t_Hashmap_Remove( int8_t_Hashmap* h, uint64_t key ) { int8_t_Hashmap_Impl_FindAndErase(h, key); } inline void int8_t_Hashmap_Reserve( int8_t_Hashmap* h, size_t capacity ) { int8_t_Hashmap_Impl_Rehash(h, capacity); } inline void int8_t_Hashmap_Clear( int8_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); int8_t_Hashmap_Entry_Array_Clear(&h->data); } inline void int8_t_Hashmap_Multi_Get( int8_t_Hashmap* h, uint64_t key, int8_t_Array * items ) { int8_t_Hashmap_Entry* e = int8_t_Hashmap_Multi_FindFirst(h, key); while (e) { int8_t_Array_Append(items, e->value); e = int8_t_Hashmap_Multi_FindNext(h, e); } } inline void int8_t_Hashmap_Multi_GetPtrs( int8_t_Hashmap* h, uint64_t key, Containment_Ptr_int8_t_Array * items ) { int8_t_Hashmap_Entry* e = int8_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_int8_t_Array_Append(items, & (e->value) ); e = int8_t_Hashmap_Multi_FindNext(h, e); } } inline size_t int8_t_Hashmap_Multi_Count( int8_t_Hashmap* h, uint64_t key ) { int8_t_Hashmap_Entry* e = int8_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = int8_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void int8_t_Hashmap_Multi_Insert( int8_t_Hashmap* h, uint64_t key, int8_t value ) { if (h->hashes.length == 0) int8_t_Hashmap_Impl_Grow(h); size_t next = int8_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (int8_t_Hashmap_Impl_Full(h)) int8_t_Hashmap_Impl_Grow(h); } inline void int8_t_Hashmap_Multi_InsertMany( int8_t_Hashmap* h, uint64_t key, int8_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { int8_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline int8_t_Hashmap_Entry* int8_t_Hashmap_Multi_FindFirst( int8_t_Hashmap* h, uint64_t key) { size_t index = int8_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline int8_t_Hashmap_Entry* int8_t_Hashmap_Multi_FindNext( int8_t_Hashmap* h, int8_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void int8_t_Hashmap_Multi_Remove( int8_t_Hashmap* h, int8_t_Hashmap_Entry* e) { FindResult fr = int8_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) int8_t_Hashmap_Impl_Erase(h, &fr); } inline void int8_t_Hashmap_Multi_RemoveAll(int8_t_Hashmap* h, uint64_t key) { while (int8_t_Hashmap_Has(h, key)) int8_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; uint8_t * data; } uint8_t_Array ; uint8_t_Array uint8_t_Array_Create(void); void uint8_t_Array_Free( uint8_t_Array* a ); uint8_t uint8_t_Array_Get( uint8_t_Array* a, size_t index); uint8_t* uint8_t_Array_GetPtr( uint8_t_Array* a, size_t index); void uint8_t_Array_Set( uint8_t_Array* a, size_t index, uint8_t value ); size_t uint8_t_Array_Append( uint8_t_Array* a, uint8_t item); size_t uint8_t_Array_AppendMany( uint8_t_Array* a, uint8_t * items, size_t count); void uint8_t_Array_PopBack( uint8_t_Array* a); size_t uint8_t_Array_Length( uint8_t_Array* a); uint8_t * uint8_t_Array_Begin( uint8_t_Array* a); uint8_t * uint8_t_Array_End( uint8_t_Array* a); uint8_t uint8_t_Array_Front( uint8_t_Array* a); uint8_t uint8_t_Array_Back( uint8_t_Array* a); void uint8_t_Array_Clear( uint8_t_Array* a); void uint8_t_Array_ShrinkToFit( uint8_t_Array* a); void uint8_t_Array_Resize( uint8_t_Array* a, size_t length); void uint8_t_Array_SetCapacity( uint8_t_Array* a, size_t capacity ); void uint8_t_Array_Reserve( uint8_t_Array* a, size_t capacity); void uint8_t_Array_Grow( uint8_t_Array* a, size_t minCapacity); inline uint8_t_Array uint8_t_Array_Create(void) { uint8_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint8_t_Array_Free( uint8_t_Array* a ) { free(a->data); } inline uint8_t uint8_t_Array_Get( uint8_t_Array* a, size_t index) { return a->data[index]; } inline uint8_t* uint8_t_Array_GetPtr( uint8_t_Array* a, size_t index) { return & (a->data[index]); } inline void uint8_t_Array_Set( uint8_t_Array* a, size_t index, uint8_t value ) { a->data[index] = value; } inline size_t uint8_t_Array_Append( uint8_t_Array* a, uint8_t item) { if (a->length + 1 > a->capacity) uint8_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint8_t_Array_AppendMany( uint8_t_Array* a, uint8_t * items, size_t count) { if (a->capacity <= a->length + count) uint8_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint8_t ) ); a->length += count; return a->length; }inline void uint8_t_Array_PopBack( uint8_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint8_t_Array_Length( uint8_t_Array* a) { return a->length; } inline size_t uint8_t_Array_Capacity(uint8_t_Array* a) { return a->capacity; } inline uint8_t * uint8_t_Array_Begin(uint8_t_Array* a) { return a->data; } inline uint8_t * uint8_t_Array_End(uint8_t_Array* a) { return a->data + a->length; } inline uint8_t uint8_t_Array_Front(uint8_t_Array* a) { assert(a->length > 0); return * ( uint8_t_Array_Begin(a) ); } inline uint8_t uint8_t_Array_Back(uint8_t_Array* a) { assert(a->length > 0); return * ( uint8_t_Array_End(a) - 1 ); } inline void uint8_t_Array_Clear(uint8_t_Array* a) { uint8_t_Array_Resize(a, 0); } inline void uint8_t_Array_ShrinkToFit(uint8_t_Array* a) { uint8_t_Array_SetCapacity(a, a->length); } inline void uint8_t_Array_Resize(uint8_t_Array* a, size_t length) { if (length > a->capacity) uint8_t_Array_Grow(a, length); a->length = length; } inline void uint8_t_Array_SetCapacity( uint8_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint8_t_Array_Resize(a, capacity); uint8_t * data = NULL; if (capacity > 0) { data = ( uint8_t * ) malloc( capacity * sizeof( uint8_t ) ); memcpy(data, a->data, a->length * sizeof( uint8_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint8_t_Array_Reserve( uint8_t_Array* a, size_t capacity) { if (capacity > a->capacity) uint8_t_Array_SetCapacity(a, capacity); } inline void uint8_t_Array_Grow( uint8_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint8_t_Array_SetCapacity(a, capacity); } typedef uint8_t *Containment_Ptr_uint8_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_uint8_t * data; } Containment_Ptr_uint8_t_Array ; Containment_Ptr_uint8_t_Array Containment_Ptr_uint8_t_Array_Create(void); void Containment_Ptr_uint8_t_Array_Free( Containment_Ptr_uint8_t_Array* a ); Containment_Ptr_uint8_t Containment_Ptr_uint8_t_Array_Get( Containment_Ptr_uint8_t_Array* a, size_t index); Containment_Ptr_uint8_t* Containment_Ptr_uint8_t_Array_GetPtr( Containment_Ptr_uint8_t_Array* a, size_t index); void Containment_Ptr_uint8_t_Array_Set( Containment_Ptr_uint8_t_Array* a, size_t index, Containment_Ptr_uint8_t value ); size_t Containment_Ptr_uint8_t_Array_Append( Containment_Ptr_uint8_t_Array* a, Containment_Ptr_uint8_t item); size_t Containment_Ptr_uint8_t_Array_AppendMany( Containment_Ptr_uint8_t_Array* a, Containment_Ptr_uint8_t * items, size_t count); void Containment_Ptr_uint8_t_Array_PopBack( Containment_Ptr_uint8_t_Array* a); size_t Containment_Ptr_uint8_t_Array_Length( Containment_Ptr_uint8_t_Array* a); Containment_Ptr_uint8_t * Containment_Ptr_uint8_t_Array_Begin( Containment_Ptr_uint8_t_Array* a); Containment_Ptr_uint8_t * Containment_Ptr_uint8_t_Array_End( Containment_Ptr_uint8_t_Array* a); Containment_Ptr_uint8_t Containment_Ptr_uint8_t_Array_Front( Containment_Ptr_uint8_t_Array* a); Containment_Ptr_uint8_t Containment_Ptr_uint8_t_Array_Back( Containment_Ptr_uint8_t_Array* a); void Containment_Ptr_uint8_t_Array_Clear( Containment_Ptr_uint8_t_Array* a); void Containment_Ptr_uint8_t_Array_ShrinkToFit( Containment_Ptr_uint8_t_Array* a); void Containment_Ptr_uint8_t_Array_Resize( Containment_Ptr_uint8_t_Array* a, size_t length); void Containment_Ptr_uint8_t_Array_SetCapacity( Containment_Ptr_uint8_t_Array* a, size_t capacity ); void Containment_Ptr_uint8_t_Array_Reserve( Containment_Ptr_uint8_t_Array* a, size_t capacity); void Containment_Ptr_uint8_t_Array_Grow( Containment_Ptr_uint8_t_Array* a, size_t minCapacity); inline Containment_Ptr_uint8_t_Array Containment_Ptr_uint8_t_Array_Create(void) { Containment_Ptr_uint8_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_uint8_t_Array_Free( Containment_Ptr_uint8_t_Array* a ) { free(a->data); } inline Containment_Ptr_uint8_t Containment_Ptr_uint8_t_Array_Get( Containment_Ptr_uint8_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_uint8_t* Containment_Ptr_uint8_t_Array_GetPtr( Containment_Ptr_uint8_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_uint8_t_Array_Set( Containment_Ptr_uint8_t_Array* a, size_t index, Containment_Ptr_uint8_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_uint8_t_Array_Append( Containment_Ptr_uint8_t_Array* a, Containment_Ptr_uint8_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_uint8_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_uint8_t_Array_AppendMany( Containment_Ptr_uint8_t_Array* a, Containment_Ptr_uint8_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_uint8_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_uint8_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_uint8_t_Array_PopBack( Containment_Ptr_uint8_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_uint8_t_Array_Length( Containment_Ptr_uint8_t_Array* a) { return a->length; } inline size_t Containment_Ptr_uint8_t_Array_Capacity(Containment_Ptr_uint8_t_Array* a) { return a->capacity; } inline Containment_Ptr_uint8_t * Containment_Ptr_uint8_t_Array_Begin(Containment_Ptr_uint8_t_Array* a) { return a->data; } inline Containment_Ptr_uint8_t * Containment_Ptr_uint8_t_Array_End(Containment_Ptr_uint8_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_uint8_t Containment_Ptr_uint8_t_Array_Front(Containment_Ptr_uint8_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint8_t_Array_Begin(a) ); } inline Containment_Ptr_uint8_t Containment_Ptr_uint8_t_Array_Back(Containment_Ptr_uint8_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint8_t_Array_End(a) - 1 ); } inline void Containment_Ptr_uint8_t_Array_Clear(Containment_Ptr_uint8_t_Array* a) { Containment_Ptr_uint8_t_Array_Resize(a, 0); } inline void Containment_Ptr_uint8_t_Array_ShrinkToFit(Containment_Ptr_uint8_t_Array* a) { Containment_Ptr_uint8_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_uint8_t_Array_Resize(Containment_Ptr_uint8_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_uint8_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_uint8_t_Array_SetCapacity( Containment_Ptr_uint8_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_uint8_t_Array_Resize(a, capacity); Containment_Ptr_uint8_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_uint8_t * ) malloc( capacity * sizeof( Containment_Ptr_uint8_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_uint8_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_uint8_t_Array_Reserve( Containment_Ptr_uint8_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_uint8_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_uint8_t_Array_Grow( Containment_Ptr_uint8_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_uint8_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; uint8_t value; } uint8_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; uint8_t_Hashmap_Entry * data; } uint8_t_Hashmap_Entry_Array ; uint8_t_Hashmap_Entry_Array uint8_t_Hashmap_Entry_Array_Create(void); void uint8_t_Hashmap_Entry_Array_Free( uint8_t_Hashmap_Entry_Array* a ); uint8_t_Hashmap_Entry uint8_t_Hashmap_Entry_Array_Get( uint8_t_Hashmap_Entry_Array* a, size_t index); uint8_t_Hashmap_Entry* uint8_t_Hashmap_Entry_Array_GetPtr( uint8_t_Hashmap_Entry_Array* a, size_t index); void uint8_t_Hashmap_Entry_Array_Set( uint8_t_Hashmap_Entry_Array* a, size_t index, uint8_t_Hashmap_Entry value ); size_t uint8_t_Hashmap_Entry_Array_Append( uint8_t_Hashmap_Entry_Array* a, uint8_t_Hashmap_Entry item); size_t uint8_t_Hashmap_Entry_Array_AppendMany( uint8_t_Hashmap_Entry_Array* a, uint8_t_Hashmap_Entry * items, size_t count); void uint8_t_Hashmap_Entry_Array_PopBack( uint8_t_Hashmap_Entry_Array* a); size_t uint8_t_Hashmap_Entry_Array_Length( uint8_t_Hashmap_Entry_Array* a); uint8_t_Hashmap_Entry * uint8_t_Hashmap_Entry_Array_Begin( uint8_t_Hashmap_Entry_Array* a); uint8_t_Hashmap_Entry * uint8_t_Hashmap_Entry_Array_End( uint8_t_Hashmap_Entry_Array* a); uint8_t_Hashmap_Entry uint8_t_Hashmap_Entry_Array_Front( uint8_t_Hashmap_Entry_Array* a); uint8_t_Hashmap_Entry uint8_t_Hashmap_Entry_Array_Back( uint8_t_Hashmap_Entry_Array* a); void uint8_t_Hashmap_Entry_Array_Clear( uint8_t_Hashmap_Entry_Array* a); void uint8_t_Hashmap_Entry_Array_ShrinkToFit( uint8_t_Hashmap_Entry_Array* a); void uint8_t_Hashmap_Entry_Array_Resize( uint8_t_Hashmap_Entry_Array* a, size_t length); void uint8_t_Hashmap_Entry_Array_SetCapacity( uint8_t_Hashmap_Entry_Array* a, size_t capacity ); void uint8_t_Hashmap_Entry_Array_Reserve( uint8_t_Hashmap_Entry_Array* a, size_t capacity); void uint8_t_Hashmap_Entry_Array_Grow( uint8_t_Hashmap_Entry_Array* a, size_t minCapacity); inline uint8_t_Hashmap_Entry_Array uint8_t_Hashmap_Entry_Array_Create(void) { uint8_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint8_t_Hashmap_Entry_Array_Free( uint8_t_Hashmap_Entry_Array* a ) { free(a->data); } inline uint8_t_Hashmap_Entry uint8_t_Hashmap_Entry_Array_Get( uint8_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline uint8_t_Hashmap_Entry* uint8_t_Hashmap_Entry_Array_GetPtr( uint8_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void uint8_t_Hashmap_Entry_Array_Set( uint8_t_Hashmap_Entry_Array* a, size_t index, uint8_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t uint8_t_Hashmap_Entry_Array_Append( uint8_t_Hashmap_Entry_Array* a, uint8_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) uint8_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint8_t_Hashmap_Entry_Array_AppendMany( uint8_t_Hashmap_Entry_Array* a, uint8_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) uint8_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint8_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void uint8_t_Hashmap_Entry_Array_PopBack( uint8_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint8_t_Hashmap_Entry_Array_Length( uint8_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t uint8_t_Hashmap_Entry_Array_Capacity(uint8_t_Hashmap_Entry_Array* a) { return a->capacity; } inline uint8_t_Hashmap_Entry * uint8_t_Hashmap_Entry_Array_Begin(uint8_t_Hashmap_Entry_Array* a) { return a->data; } inline uint8_t_Hashmap_Entry * uint8_t_Hashmap_Entry_Array_End(uint8_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline uint8_t_Hashmap_Entry uint8_t_Hashmap_Entry_Array_Front(uint8_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint8_t_Hashmap_Entry_Array_Begin(a) ); } inline uint8_t_Hashmap_Entry uint8_t_Hashmap_Entry_Array_Back(uint8_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint8_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void uint8_t_Hashmap_Entry_Array_Clear(uint8_t_Hashmap_Entry_Array* a) { uint8_t_Hashmap_Entry_Array_Resize(a, 0); } inline void uint8_t_Hashmap_Entry_Array_ShrinkToFit(uint8_t_Hashmap_Entry_Array* a) { uint8_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void uint8_t_Hashmap_Entry_Array_Resize(uint8_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) uint8_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void uint8_t_Hashmap_Entry_Array_SetCapacity( uint8_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint8_t_Hashmap_Entry_Array_Resize(a, capacity); uint8_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( uint8_t_Hashmap_Entry * ) malloc( capacity * sizeof( uint8_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( uint8_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint8_t_Hashmap_Entry_Array_Reserve( uint8_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) uint8_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void uint8_t_Hashmap_Entry_Array_Grow( uint8_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint8_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; uint8_t_Hashmap_Entry_Array data; } uint8_t_Hashmap; uint8_t_Hashmap uint8_t_Hashmap_Create(void); void uint8_t_Hashmap_Free( uint8_t_Hashmap* h); size_t uint8_t_Hashmap_Impl_AddEntry( uint8_t_Hashmap* h, uint64_t key); void uint8_t_Hashmap_Impl_Erase( uint8_t_Hashmap* h, FindResult* fr); FindResult uint8_t_Hashmap_Impl_FindByKey( uint8_t_Hashmap* h, uint64_t key); FindResult uint8_t_Hashmap_Impl_FindByEntry( uint8_t_Hashmap* h, uint8_t_Hashmap_Entry* e); size_t uint8_t_Hashmap_Impl_Make( uint8_t_Hashmap* h, uint64_t key); void uint8_t_Hashmap_Impl_FindAndErase(uint8_t_Hashmap* h, uint64_t key); size_t uint8_t_Hashmap_Impl_FindOrFail(uint8_t_Hashmap* h, uint64_t key); size_t uint8_t_Hashmap_Impl_FindOrMake( uint8_t_Hashmap* h, uint64_t key); void uint8_t_Hashmap_Impl_Rehash( uint8_t_Hashmap* h, size_t newCapacity); void uint8_t_Hashmap_Impl_Grow( uint8_t_Hashmap* h); char uint8_t_Hashmap_Impl_Full( uint8_t_Hashmap* h); char uint8_t_Hashmap_Has( uint8_t_Hashmap* h, uint64_t key); uint8_t uint8_t_Hashmap_Get( uint8_t_Hashmap* h, uint64_t key, uint8_t defaultValue ); uint8_t * uint8_t_Hashmap_GetPtr( uint8_t_Hashmap* h, uint64_t key, uint8_t * defaultValue ); size_t uint8_t_Hashmap_Set( uint8_t_Hashmap* h, uint64_t key, uint8_t value ); size_t uint8_t_Hashmap_SetPtr( uint8_t_Hashmap* h, uint64_t key, uint8_t* value ); void uint8_t_Hashmap_Remove( uint8_t_Hashmap* h, uint64_t key ); void uint8_t_Hashmap_Reserve( uint8_t_Hashmap* h, size_t capacity ); void uint8_t_Hashmap_Clear( uint8_t_Hashmap* h ); void uint8_t_Hashmap_Multi_Get( uint8_t_Hashmap* h, uint64_t key, uint8_t_Array * items ); void uint8_t_Hashmap_Multi_GetPtrs( uint8_t_Hashmap* h, uint64_t key, Containment_Ptr_uint8_t_Array * items ); size_t uint8_t_Hashmap_Multi_Count( uint8_t_Hashmap* h, uint64_t key ); void uint8_t_Hashmap_Multi_Insert( uint8_t_Hashmap* h, uint64_t key, uint8_t value ); void uint8_t_Hashmap_Multi_InsertMany( uint8_t_Hashmap* h, uint64_t key, uint8_t * values, size_t count ); uint8_t_Hashmap_Entry* uint8_t_Hashmap_Multi_FindFirst( uint8_t_Hashmap* h, uint64_t key); uint8_t_Hashmap_Entry* uint8_t_Hashmap_Multi_FindNext( uint8_t_Hashmap* h, uint8_t_Hashmap_Entry* e); void uint8_t_Hashmap_Multi_Remove( uint8_t_Hashmap* h, uint8_t_Hashmap_Entry* e); void uint8_t_Hashmap_Multi_RemoveAll(uint8_t_Hashmap* h, uint64_t key); inline uint8_t_Hashmap uint8_t_Hashmap_Create(void) { uint8_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = uint8_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void uint8_t_Hashmap_Free( uint8_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); uint8_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t uint8_t_Hashmap_Impl_AddEntry( uint8_t_Hashmap* h, uint64_t key) { uint8_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; uint8_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void uint8_t_Hashmap_Impl_Erase( uint8_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; uint8_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = uint8_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult uint8_t_Hashmap_Impl_FindByKey( uint8_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult uint8_t_Hashmap_Impl_FindByEntry( uint8_t_Hashmap* h, uint8_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t uint8_t_Hashmap_Impl_Make( uint8_t_Hashmap* h, uint64_t key) { FindResult fr = uint8_t_Hashmap_Impl_FindByKey(h, key); size_t index = uint8_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void uint8_t_Hashmap_Impl_FindAndErase( uint8_t_Hashmap* h, uint64_t key) { FindResult fr = uint8_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) uint8_t_Hashmap_Impl_Erase(h, &fr); } inline size_t uint8_t_Hashmap_Impl_FindOrFail( uint8_t_Hashmap* h, uint64_t key) { return uint8_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t uint8_t_Hashmap_Impl_FindOrMake( uint8_t_Hashmap* h, uint64_t key) { FindResult fr = uint8_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = uint8_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void uint8_t_Hashmap_Impl_Rehash( uint8_t_Hashmap* h, size_t newCapacity) { uint8_t_Hashmap nh = uint8_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; uint8_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { uint8_t_Hashmap_Entry* e = &h->data.data[i]; uint8_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = uint8_t_Hashmap_Create(); } inline void uint8_t_Hashmap_Impl_Grow( uint8_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; uint8_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char uint8_t_Hashmap_Impl_Full( uint8_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char uint8_t_Hashmap_Has( uint8_t_Hashmap* h, uint64_t key) { return uint8_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline uint8_t uint8_t_Hashmap_Get( uint8_t_Hashmap* h, uint64_t key, uint8_t defaultValue ) { size_t index = uint8_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline uint8_t * uint8_t_Hashmap_GetPtr( uint8_t_Hashmap* h, uint64_t key, uint8_t * defaultValue ) { size_t index = uint8_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t uint8_t_Hashmap_Set( uint8_t_Hashmap* h, uint64_t key, uint8_t value ) { if (h->hashes.length == 0) uint8_t_Hashmap_Impl_Grow(h); size_t index = uint8_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (uint8_t_Hashmap_Impl_Full(h)) uint8_t_Hashmap_Impl_Grow(h); return index; } inline size_t uint8_t_Hashmap_SetPtr( uint8_t_Hashmap* h, uint64_t key, uint8_t* value ) { if (h->hashes.length == 0) uint8_t_Hashmap_Impl_Grow(h); size_t index = uint8_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (uint8_t_Hashmap_Impl_Full(h)) uint8_t_Hashmap_Impl_Grow(h); return index; } inline void uint8_t_Hashmap_Remove( uint8_t_Hashmap* h, uint64_t key ) { uint8_t_Hashmap_Impl_FindAndErase(h, key); } inline void uint8_t_Hashmap_Reserve( uint8_t_Hashmap* h, size_t capacity ) { uint8_t_Hashmap_Impl_Rehash(h, capacity); } inline void uint8_t_Hashmap_Clear( uint8_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); uint8_t_Hashmap_Entry_Array_Clear(&h->data); } inline void uint8_t_Hashmap_Multi_Get( uint8_t_Hashmap* h, uint64_t key, uint8_t_Array * items ) { uint8_t_Hashmap_Entry* e = uint8_t_Hashmap_Multi_FindFirst(h, key); while (e) { uint8_t_Array_Append(items, e->value); e = uint8_t_Hashmap_Multi_FindNext(h, e); } } inline void uint8_t_Hashmap_Multi_GetPtrs( uint8_t_Hashmap* h, uint64_t key, Containment_Ptr_uint8_t_Array * items ) { uint8_t_Hashmap_Entry* e = uint8_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_uint8_t_Array_Append(items, & (e->value) ); e = uint8_t_Hashmap_Multi_FindNext(h, e); } } inline size_t uint8_t_Hashmap_Multi_Count( uint8_t_Hashmap* h, uint64_t key ) { uint8_t_Hashmap_Entry* e = uint8_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = uint8_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void uint8_t_Hashmap_Multi_Insert( uint8_t_Hashmap* h, uint64_t key, uint8_t value ) { if (h->hashes.length == 0) uint8_t_Hashmap_Impl_Grow(h); size_t next = uint8_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (uint8_t_Hashmap_Impl_Full(h)) uint8_t_Hashmap_Impl_Grow(h); } inline void uint8_t_Hashmap_Multi_InsertMany( uint8_t_Hashmap* h, uint64_t key, uint8_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { uint8_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline uint8_t_Hashmap_Entry* uint8_t_Hashmap_Multi_FindFirst( uint8_t_Hashmap* h, uint64_t key) { size_t index = uint8_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline uint8_t_Hashmap_Entry* uint8_t_Hashmap_Multi_FindNext( uint8_t_Hashmap* h, uint8_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void uint8_t_Hashmap_Multi_Remove( uint8_t_Hashmap* h, uint8_t_Hashmap_Entry* e) { FindResult fr = uint8_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) uint8_t_Hashmap_Impl_Erase(h, &fr); } inline void uint8_t_Hashmap_Multi_RemoveAll(uint8_t_Hashmap* h, uint64_t key) { while (uint8_t_Hashmap_Has(h, key)) uint8_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; int16_t * data; } int16_t_Array ; int16_t_Array int16_t_Array_Create(void); void int16_t_Array_Free( int16_t_Array* a ); int16_t int16_t_Array_Get( int16_t_Array* a, size_t index); int16_t* int16_t_Array_GetPtr( int16_t_Array* a, size_t index); void int16_t_Array_Set( int16_t_Array* a, size_t index, int16_t value ); size_t int16_t_Array_Append( int16_t_Array* a, int16_t item); size_t int16_t_Array_AppendMany( int16_t_Array* a, int16_t * items, size_t count); void int16_t_Array_PopBack( int16_t_Array* a); size_t int16_t_Array_Length( int16_t_Array* a); int16_t * int16_t_Array_Begin( int16_t_Array* a); int16_t * int16_t_Array_End( int16_t_Array* a); int16_t int16_t_Array_Front( int16_t_Array* a); int16_t int16_t_Array_Back( int16_t_Array* a); void int16_t_Array_Clear( int16_t_Array* a); void int16_t_Array_ShrinkToFit( int16_t_Array* a); void int16_t_Array_Resize( int16_t_Array* a, size_t length); void int16_t_Array_SetCapacity( int16_t_Array* a, size_t capacity ); void int16_t_Array_Reserve( int16_t_Array* a, size_t capacity); void int16_t_Array_Grow( int16_t_Array* a, size_t minCapacity); inline int16_t_Array int16_t_Array_Create(void) { int16_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int16_t_Array_Free( int16_t_Array* a ) { free(a->data); } inline int16_t int16_t_Array_Get( int16_t_Array* a, size_t index) { return a->data[index]; } inline int16_t* int16_t_Array_GetPtr( int16_t_Array* a, size_t index) { return & (a->data[index]); } inline void int16_t_Array_Set( int16_t_Array* a, size_t index, int16_t value ) { a->data[index] = value; } inline size_t int16_t_Array_Append( int16_t_Array* a, int16_t item) { if (a->length + 1 > a->capacity) int16_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int16_t_Array_AppendMany( int16_t_Array* a, int16_t * items, size_t count) { if (a->capacity <= a->length + count) int16_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int16_t ) ); a->length += count; return a->length; }inline void int16_t_Array_PopBack( int16_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t int16_t_Array_Length( int16_t_Array* a) { return a->length; } inline size_t int16_t_Array_Capacity(int16_t_Array* a) { return a->capacity; } inline int16_t * int16_t_Array_Begin(int16_t_Array* a) { return a->data; } inline int16_t * int16_t_Array_End(int16_t_Array* a) { return a->data + a->length; } inline int16_t int16_t_Array_Front(int16_t_Array* a) { assert(a->length > 0); return * ( int16_t_Array_Begin(a) ); } inline int16_t int16_t_Array_Back(int16_t_Array* a) { assert(a->length > 0); return * ( int16_t_Array_End(a) - 1 ); } inline void int16_t_Array_Clear(int16_t_Array* a) { int16_t_Array_Resize(a, 0); } inline void int16_t_Array_ShrinkToFit(int16_t_Array* a) { int16_t_Array_SetCapacity(a, a->length); } inline void int16_t_Array_Resize(int16_t_Array* a, size_t length) { if (length > a->capacity) int16_t_Array_Grow(a, length); a->length = length; } inline void int16_t_Array_SetCapacity( int16_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int16_t_Array_Resize(a, capacity); int16_t * data = NULL; if (capacity > 0) { data = ( int16_t * ) malloc( capacity * sizeof( int16_t ) ); memcpy(data, a->data, a->length * sizeof( int16_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int16_t_Array_Reserve( int16_t_Array* a, size_t capacity) { if (capacity > a->capacity) int16_t_Array_SetCapacity(a, capacity); } inline void int16_t_Array_Grow( int16_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int16_t_Array_SetCapacity(a, capacity); } typedef int16_t *Containment_Ptr_int16_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_int16_t * data; } Containment_Ptr_int16_t_Array ; Containment_Ptr_int16_t_Array Containment_Ptr_int16_t_Array_Create(void); void Containment_Ptr_int16_t_Array_Free( Containment_Ptr_int16_t_Array* a ); Containment_Ptr_int16_t Containment_Ptr_int16_t_Array_Get( Containment_Ptr_int16_t_Array* a, size_t index); Containment_Ptr_int16_t* Containment_Ptr_int16_t_Array_GetPtr( Containment_Ptr_int16_t_Array* a, size_t index); void Containment_Ptr_int16_t_Array_Set( Containment_Ptr_int16_t_Array* a, size_t index, Containment_Ptr_int16_t value ); size_t Containment_Ptr_int16_t_Array_Append( Containment_Ptr_int16_t_Array* a, Containment_Ptr_int16_t item); size_t Containment_Ptr_int16_t_Array_AppendMany( Containment_Ptr_int16_t_Array* a, Containment_Ptr_int16_t * items, size_t count); void Containment_Ptr_int16_t_Array_PopBack( Containment_Ptr_int16_t_Array* a); size_t Containment_Ptr_int16_t_Array_Length( Containment_Ptr_int16_t_Array* a); Containment_Ptr_int16_t * Containment_Ptr_int16_t_Array_Begin( Containment_Ptr_int16_t_Array* a); Containment_Ptr_int16_t * Containment_Ptr_int16_t_Array_End( Containment_Ptr_int16_t_Array* a); Containment_Ptr_int16_t Containment_Ptr_int16_t_Array_Front( Containment_Ptr_int16_t_Array* a); Containment_Ptr_int16_t Containment_Ptr_int16_t_Array_Back( Containment_Ptr_int16_t_Array* a); void Containment_Ptr_int16_t_Array_Clear( Containment_Ptr_int16_t_Array* a); void Containment_Ptr_int16_t_Array_ShrinkToFit( Containment_Ptr_int16_t_Array* a); void Containment_Ptr_int16_t_Array_Resize( Containment_Ptr_int16_t_Array* a, size_t length); void Containment_Ptr_int16_t_Array_SetCapacity( Containment_Ptr_int16_t_Array* a, size_t capacity ); void Containment_Ptr_int16_t_Array_Reserve( Containment_Ptr_int16_t_Array* a, size_t capacity); void Containment_Ptr_int16_t_Array_Grow( Containment_Ptr_int16_t_Array* a, size_t minCapacity); inline Containment_Ptr_int16_t_Array Containment_Ptr_int16_t_Array_Create(void) { Containment_Ptr_int16_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_int16_t_Array_Free( Containment_Ptr_int16_t_Array* a ) { free(a->data); } inline Containment_Ptr_int16_t Containment_Ptr_int16_t_Array_Get( Containment_Ptr_int16_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_int16_t* Containment_Ptr_int16_t_Array_GetPtr( Containment_Ptr_int16_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_int16_t_Array_Set( Containment_Ptr_int16_t_Array* a, size_t index, Containment_Ptr_int16_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_int16_t_Array_Append( Containment_Ptr_int16_t_Array* a, Containment_Ptr_int16_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_int16_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_int16_t_Array_AppendMany( Containment_Ptr_int16_t_Array* a, Containment_Ptr_int16_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_int16_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_int16_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_int16_t_Array_PopBack( Containment_Ptr_int16_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_int16_t_Array_Length( Containment_Ptr_int16_t_Array* a) { return a->length; } inline size_t Containment_Ptr_int16_t_Array_Capacity(Containment_Ptr_int16_t_Array* a) { return a->capacity; } inline Containment_Ptr_int16_t * Containment_Ptr_int16_t_Array_Begin(Containment_Ptr_int16_t_Array* a) { return a->data; } inline Containment_Ptr_int16_t * Containment_Ptr_int16_t_Array_End(Containment_Ptr_int16_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_int16_t Containment_Ptr_int16_t_Array_Front(Containment_Ptr_int16_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int16_t_Array_Begin(a) ); } inline Containment_Ptr_int16_t Containment_Ptr_int16_t_Array_Back(Containment_Ptr_int16_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int16_t_Array_End(a) - 1 ); } inline void Containment_Ptr_int16_t_Array_Clear(Containment_Ptr_int16_t_Array* a) { Containment_Ptr_int16_t_Array_Resize(a, 0); } inline void Containment_Ptr_int16_t_Array_ShrinkToFit(Containment_Ptr_int16_t_Array* a) { Containment_Ptr_int16_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_int16_t_Array_Resize(Containment_Ptr_int16_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_int16_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_int16_t_Array_SetCapacity( Containment_Ptr_int16_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_int16_t_Array_Resize(a, capacity); Containment_Ptr_int16_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_int16_t * ) malloc( capacity * sizeof( Containment_Ptr_int16_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_int16_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_int16_t_Array_Reserve( Containment_Ptr_int16_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_int16_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_int16_t_Array_Grow( Containment_Ptr_int16_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_int16_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; int16_t value; } int16_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; int16_t_Hashmap_Entry * data; } int16_t_Hashmap_Entry_Array ; int16_t_Hashmap_Entry_Array int16_t_Hashmap_Entry_Array_Create(void); void int16_t_Hashmap_Entry_Array_Free( int16_t_Hashmap_Entry_Array* a ); int16_t_Hashmap_Entry int16_t_Hashmap_Entry_Array_Get( int16_t_Hashmap_Entry_Array* a, size_t index); int16_t_Hashmap_Entry* int16_t_Hashmap_Entry_Array_GetPtr( int16_t_Hashmap_Entry_Array* a, size_t index); void int16_t_Hashmap_Entry_Array_Set( int16_t_Hashmap_Entry_Array* a, size_t index, int16_t_Hashmap_Entry value ); size_t int16_t_Hashmap_Entry_Array_Append( int16_t_Hashmap_Entry_Array* a, int16_t_Hashmap_Entry item); size_t int16_t_Hashmap_Entry_Array_AppendMany( int16_t_Hashmap_Entry_Array* a, int16_t_Hashmap_Entry * items, size_t count); void int16_t_Hashmap_Entry_Array_PopBack( int16_t_Hashmap_Entry_Array* a); size_t int16_t_Hashmap_Entry_Array_Length( int16_t_Hashmap_Entry_Array* a); int16_t_Hashmap_Entry * int16_t_Hashmap_Entry_Array_Begin( int16_t_Hashmap_Entry_Array* a); int16_t_Hashmap_Entry * int16_t_Hashmap_Entry_Array_End( int16_t_Hashmap_Entry_Array* a); int16_t_Hashmap_Entry int16_t_Hashmap_Entry_Array_Front( int16_t_Hashmap_Entry_Array* a); int16_t_Hashmap_Entry int16_t_Hashmap_Entry_Array_Back( int16_t_Hashmap_Entry_Array* a); void int16_t_Hashmap_Entry_Array_Clear( int16_t_Hashmap_Entry_Array* a); void int16_t_Hashmap_Entry_Array_ShrinkToFit( int16_t_Hashmap_Entry_Array* a); void int16_t_Hashmap_Entry_Array_Resize( int16_t_Hashmap_Entry_Array* a, size_t length); void int16_t_Hashmap_Entry_Array_SetCapacity( int16_t_Hashmap_Entry_Array* a, size_t capacity ); void int16_t_Hashmap_Entry_Array_Reserve( int16_t_Hashmap_Entry_Array* a, size_t capacity); void int16_t_Hashmap_Entry_Array_Grow( int16_t_Hashmap_Entry_Array* a, size_t minCapacity); inline int16_t_Hashmap_Entry_Array int16_t_Hashmap_Entry_Array_Create(void) { int16_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int16_t_Hashmap_Entry_Array_Free( int16_t_Hashmap_Entry_Array* a ) { free(a->data); } inline int16_t_Hashmap_Entry int16_t_Hashmap_Entry_Array_Get( int16_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline int16_t_Hashmap_Entry* int16_t_Hashmap_Entry_Array_GetPtr( int16_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void int16_t_Hashmap_Entry_Array_Set( int16_t_Hashmap_Entry_Array* a, size_t index, int16_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t int16_t_Hashmap_Entry_Array_Append( int16_t_Hashmap_Entry_Array* a, int16_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) int16_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int16_t_Hashmap_Entry_Array_AppendMany( int16_t_Hashmap_Entry_Array* a, int16_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) int16_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int16_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void int16_t_Hashmap_Entry_Array_PopBack( int16_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t int16_t_Hashmap_Entry_Array_Length( int16_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t int16_t_Hashmap_Entry_Array_Capacity(int16_t_Hashmap_Entry_Array* a) { return a->capacity; } inline int16_t_Hashmap_Entry * int16_t_Hashmap_Entry_Array_Begin(int16_t_Hashmap_Entry_Array* a) { return a->data; } inline int16_t_Hashmap_Entry * int16_t_Hashmap_Entry_Array_End(int16_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline int16_t_Hashmap_Entry int16_t_Hashmap_Entry_Array_Front(int16_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int16_t_Hashmap_Entry_Array_Begin(a) ); } inline int16_t_Hashmap_Entry int16_t_Hashmap_Entry_Array_Back(int16_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int16_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void int16_t_Hashmap_Entry_Array_Clear(int16_t_Hashmap_Entry_Array* a) { int16_t_Hashmap_Entry_Array_Resize(a, 0); } inline void int16_t_Hashmap_Entry_Array_ShrinkToFit(int16_t_Hashmap_Entry_Array* a) { int16_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void int16_t_Hashmap_Entry_Array_Resize(int16_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) int16_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void int16_t_Hashmap_Entry_Array_SetCapacity( int16_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int16_t_Hashmap_Entry_Array_Resize(a, capacity); int16_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( int16_t_Hashmap_Entry * ) malloc( capacity * sizeof( int16_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( int16_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int16_t_Hashmap_Entry_Array_Reserve( int16_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) int16_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void int16_t_Hashmap_Entry_Array_Grow( int16_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int16_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; int16_t_Hashmap_Entry_Array data; } int16_t_Hashmap; int16_t_Hashmap int16_t_Hashmap_Create(void); void int16_t_Hashmap_Free( int16_t_Hashmap* h); size_t int16_t_Hashmap_Impl_AddEntry( int16_t_Hashmap* h, uint64_t key); void int16_t_Hashmap_Impl_Erase( int16_t_Hashmap* h, FindResult* fr); FindResult int16_t_Hashmap_Impl_FindByKey( int16_t_Hashmap* h, uint64_t key); FindResult int16_t_Hashmap_Impl_FindByEntry( int16_t_Hashmap* h, int16_t_Hashmap_Entry* e); size_t int16_t_Hashmap_Impl_Make( int16_t_Hashmap* h, uint64_t key); void int16_t_Hashmap_Impl_FindAndErase(int16_t_Hashmap* h, uint64_t key); size_t int16_t_Hashmap_Impl_FindOrFail(int16_t_Hashmap* h, uint64_t key); size_t int16_t_Hashmap_Impl_FindOrMake( int16_t_Hashmap* h, uint64_t key); void int16_t_Hashmap_Impl_Rehash( int16_t_Hashmap* h, size_t newCapacity); void int16_t_Hashmap_Impl_Grow( int16_t_Hashmap* h); char int16_t_Hashmap_Impl_Full( int16_t_Hashmap* h); char int16_t_Hashmap_Has( int16_t_Hashmap* h, uint64_t key); int16_t int16_t_Hashmap_Get( int16_t_Hashmap* h, uint64_t key, int16_t defaultValue ); int16_t * int16_t_Hashmap_GetPtr( int16_t_Hashmap* h, uint64_t key, int16_t * defaultValue ); size_t int16_t_Hashmap_Set( int16_t_Hashmap* h, uint64_t key, int16_t value ); size_t int16_t_Hashmap_SetPtr( int16_t_Hashmap* h, uint64_t key, int16_t* value ); void int16_t_Hashmap_Remove( int16_t_Hashmap* h, uint64_t key ); void int16_t_Hashmap_Reserve( int16_t_Hashmap* h, size_t capacity ); void int16_t_Hashmap_Clear( int16_t_Hashmap* h ); void int16_t_Hashmap_Multi_Get( int16_t_Hashmap* h, uint64_t key, int16_t_Array * items ); void int16_t_Hashmap_Multi_GetPtrs( int16_t_Hashmap* h, uint64_t key, Containment_Ptr_int16_t_Array * items ); size_t int16_t_Hashmap_Multi_Count( int16_t_Hashmap* h, uint64_t key ); void int16_t_Hashmap_Multi_Insert( int16_t_Hashmap* h, uint64_t key, int16_t value ); void int16_t_Hashmap_Multi_InsertMany( int16_t_Hashmap* h, uint64_t key, int16_t * values, size_t count ); int16_t_Hashmap_Entry* int16_t_Hashmap_Multi_FindFirst( int16_t_Hashmap* h, uint64_t key); int16_t_Hashmap_Entry* int16_t_Hashmap_Multi_FindNext( int16_t_Hashmap* h, int16_t_Hashmap_Entry* e); void int16_t_Hashmap_Multi_Remove( int16_t_Hashmap* h, int16_t_Hashmap_Entry* e); void int16_t_Hashmap_Multi_RemoveAll(int16_t_Hashmap* h, uint64_t key); inline int16_t_Hashmap int16_t_Hashmap_Create(void) { int16_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = int16_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void int16_t_Hashmap_Free( int16_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); int16_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t int16_t_Hashmap_Impl_AddEntry( int16_t_Hashmap* h, uint64_t key) { int16_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; int16_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void int16_t_Hashmap_Impl_Erase( int16_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; int16_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = int16_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult int16_t_Hashmap_Impl_FindByKey( int16_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult int16_t_Hashmap_Impl_FindByEntry( int16_t_Hashmap* h, int16_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t int16_t_Hashmap_Impl_Make( int16_t_Hashmap* h, uint64_t key) { FindResult fr = int16_t_Hashmap_Impl_FindByKey(h, key); size_t index = int16_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void int16_t_Hashmap_Impl_FindAndErase( int16_t_Hashmap* h, uint64_t key) { FindResult fr = int16_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) int16_t_Hashmap_Impl_Erase(h, &fr); } inline size_t int16_t_Hashmap_Impl_FindOrFail( int16_t_Hashmap* h, uint64_t key) { return int16_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t int16_t_Hashmap_Impl_FindOrMake( int16_t_Hashmap* h, uint64_t key) { FindResult fr = int16_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = int16_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void int16_t_Hashmap_Impl_Rehash( int16_t_Hashmap* h, size_t newCapacity) { int16_t_Hashmap nh = int16_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; int16_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { int16_t_Hashmap_Entry* e = &h->data.data[i]; int16_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = int16_t_Hashmap_Create(); } inline void int16_t_Hashmap_Impl_Grow( int16_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; int16_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char int16_t_Hashmap_Impl_Full( int16_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char int16_t_Hashmap_Has( int16_t_Hashmap* h, uint64_t key) { return int16_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline int16_t int16_t_Hashmap_Get( int16_t_Hashmap* h, uint64_t key, int16_t defaultValue ) { size_t index = int16_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline int16_t * int16_t_Hashmap_GetPtr( int16_t_Hashmap* h, uint64_t key, int16_t * defaultValue ) { size_t index = int16_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t int16_t_Hashmap_Set( int16_t_Hashmap* h, uint64_t key, int16_t value ) { if (h->hashes.length == 0) int16_t_Hashmap_Impl_Grow(h); size_t index = int16_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (int16_t_Hashmap_Impl_Full(h)) int16_t_Hashmap_Impl_Grow(h); return index; } inline size_t int16_t_Hashmap_SetPtr( int16_t_Hashmap* h, uint64_t key, int16_t* value ) { if (h->hashes.length == 0) int16_t_Hashmap_Impl_Grow(h); size_t index = int16_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (int16_t_Hashmap_Impl_Full(h)) int16_t_Hashmap_Impl_Grow(h); return index; } inline void int16_t_Hashmap_Remove( int16_t_Hashmap* h, uint64_t key ) { int16_t_Hashmap_Impl_FindAndErase(h, key); } inline void int16_t_Hashmap_Reserve( int16_t_Hashmap* h, size_t capacity ) { int16_t_Hashmap_Impl_Rehash(h, capacity); } inline void int16_t_Hashmap_Clear( int16_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); int16_t_Hashmap_Entry_Array_Clear(&h->data); } inline void int16_t_Hashmap_Multi_Get( int16_t_Hashmap* h, uint64_t key, int16_t_Array * items ) { int16_t_Hashmap_Entry* e = int16_t_Hashmap_Multi_FindFirst(h, key); while (e) { int16_t_Array_Append(items, e->value); e = int16_t_Hashmap_Multi_FindNext(h, e); } } inline void int16_t_Hashmap_Multi_GetPtrs( int16_t_Hashmap* h, uint64_t key, Containment_Ptr_int16_t_Array * items ) { int16_t_Hashmap_Entry* e = int16_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_int16_t_Array_Append(items, & (e->value) ); e = int16_t_Hashmap_Multi_FindNext(h, e); } } inline size_t int16_t_Hashmap_Multi_Count( int16_t_Hashmap* h, uint64_t key ) { int16_t_Hashmap_Entry* e = int16_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = int16_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void int16_t_Hashmap_Multi_Insert( int16_t_Hashmap* h, uint64_t key, int16_t value ) { if (h->hashes.length == 0) int16_t_Hashmap_Impl_Grow(h); size_t next = int16_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (int16_t_Hashmap_Impl_Full(h)) int16_t_Hashmap_Impl_Grow(h); } inline void int16_t_Hashmap_Multi_InsertMany( int16_t_Hashmap* h, uint64_t key, int16_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { int16_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline int16_t_Hashmap_Entry* int16_t_Hashmap_Multi_FindFirst( int16_t_Hashmap* h, uint64_t key) { size_t index = int16_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline int16_t_Hashmap_Entry* int16_t_Hashmap_Multi_FindNext( int16_t_Hashmap* h, int16_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void int16_t_Hashmap_Multi_Remove( int16_t_Hashmap* h, int16_t_Hashmap_Entry* e) { FindResult fr = int16_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) int16_t_Hashmap_Impl_Erase(h, &fr); } inline void int16_t_Hashmap_Multi_RemoveAll(int16_t_Hashmap* h, uint64_t key) { while (int16_t_Hashmap_Has(h, key)) int16_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; uint16_t * data; } uint16_t_Array ; uint16_t_Array uint16_t_Array_Create(void); void uint16_t_Array_Free( uint16_t_Array* a ); uint16_t uint16_t_Array_Get( uint16_t_Array* a, size_t index); uint16_t* uint16_t_Array_GetPtr( uint16_t_Array* a, size_t index); void uint16_t_Array_Set( uint16_t_Array* a, size_t index, uint16_t value ); size_t uint16_t_Array_Append( uint16_t_Array* a, uint16_t item); size_t uint16_t_Array_AppendMany( uint16_t_Array* a, uint16_t * items, size_t count); void uint16_t_Array_PopBack( uint16_t_Array* a); size_t uint16_t_Array_Length( uint16_t_Array* a); uint16_t * uint16_t_Array_Begin( uint16_t_Array* a); uint16_t * uint16_t_Array_End( uint16_t_Array* a); uint16_t uint16_t_Array_Front( uint16_t_Array* a); uint16_t uint16_t_Array_Back( uint16_t_Array* a); void uint16_t_Array_Clear( uint16_t_Array* a); void uint16_t_Array_ShrinkToFit( uint16_t_Array* a); void uint16_t_Array_Resize( uint16_t_Array* a, size_t length); void uint16_t_Array_SetCapacity( uint16_t_Array* a, size_t capacity ); void uint16_t_Array_Reserve( uint16_t_Array* a, size_t capacity); void uint16_t_Array_Grow( uint16_t_Array* a, size_t minCapacity); inline uint16_t_Array uint16_t_Array_Create(void) { uint16_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint16_t_Array_Free( uint16_t_Array* a ) { free(a->data); } inline uint16_t uint16_t_Array_Get( uint16_t_Array* a, size_t index) { return a->data[index]; } inline uint16_t* uint16_t_Array_GetPtr( uint16_t_Array* a, size_t index) { return & (a->data[index]); } inline void uint16_t_Array_Set( uint16_t_Array* a, size_t index, uint16_t value ) { a->data[index] = value; } inline size_t uint16_t_Array_Append( uint16_t_Array* a, uint16_t item) { if (a->length + 1 > a->capacity) uint16_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint16_t_Array_AppendMany( uint16_t_Array* a, uint16_t * items, size_t count) { if (a->capacity <= a->length + count) uint16_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint16_t ) ); a->length += count; return a->length; }inline void uint16_t_Array_PopBack( uint16_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint16_t_Array_Length( uint16_t_Array* a) { return a->length; } inline size_t uint16_t_Array_Capacity(uint16_t_Array* a) { return a->capacity; } inline uint16_t * uint16_t_Array_Begin(uint16_t_Array* a) { return a->data; } inline uint16_t * uint16_t_Array_End(uint16_t_Array* a) { return a->data + a->length; } inline uint16_t uint16_t_Array_Front(uint16_t_Array* a) { assert(a->length > 0); return * ( uint16_t_Array_Begin(a) ); } inline uint16_t uint16_t_Array_Back(uint16_t_Array* a) { assert(a->length > 0); return * ( uint16_t_Array_End(a) - 1 ); } inline void uint16_t_Array_Clear(uint16_t_Array* a) { uint16_t_Array_Resize(a, 0); } inline void uint16_t_Array_ShrinkToFit(uint16_t_Array* a) { uint16_t_Array_SetCapacity(a, a->length); } inline void uint16_t_Array_Resize(uint16_t_Array* a, size_t length) { if (length > a->capacity) uint16_t_Array_Grow(a, length); a->length = length; } inline void uint16_t_Array_SetCapacity( uint16_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint16_t_Array_Resize(a, capacity); uint16_t * data = NULL; if (capacity > 0) { data = ( uint16_t * ) malloc( capacity * sizeof( uint16_t ) ); memcpy(data, a->data, a->length * sizeof( uint16_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint16_t_Array_Reserve( uint16_t_Array* a, size_t capacity) { if (capacity > a->capacity) uint16_t_Array_SetCapacity(a, capacity); } inline void uint16_t_Array_Grow( uint16_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint16_t_Array_SetCapacity(a, capacity); } typedef uint16_t *Containment_Ptr_uint16_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_uint16_t * data; } Containment_Ptr_uint16_t_Array ; Containment_Ptr_uint16_t_Array Containment_Ptr_uint16_t_Array_Create(void); void Containment_Ptr_uint16_t_Array_Free( Containment_Ptr_uint16_t_Array* a ); Containment_Ptr_uint16_t Containment_Ptr_uint16_t_Array_Get( Containment_Ptr_uint16_t_Array* a, size_t index); Containment_Ptr_uint16_t* Containment_Ptr_uint16_t_Array_GetPtr( Containment_Ptr_uint16_t_Array* a, size_t index); void Containment_Ptr_uint16_t_Array_Set( Containment_Ptr_uint16_t_Array* a, size_t index, Containment_Ptr_uint16_t value ); size_t Containment_Ptr_uint16_t_Array_Append( Containment_Ptr_uint16_t_Array* a, Containment_Ptr_uint16_t item); size_t Containment_Ptr_uint16_t_Array_AppendMany( Containment_Ptr_uint16_t_Array* a, Containment_Ptr_uint16_t * items, size_t count); void Containment_Ptr_uint16_t_Array_PopBack( Containment_Ptr_uint16_t_Array* a); size_t Containment_Ptr_uint16_t_Array_Length( Containment_Ptr_uint16_t_Array* a); Containment_Ptr_uint16_t * Containment_Ptr_uint16_t_Array_Begin( Containment_Ptr_uint16_t_Array* a); Containment_Ptr_uint16_t * Containment_Ptr_uint16_t_Array_End( Containment_Ptr_uint16_t_Array* a); Containment_Ptr_uint16_t Containment_Ptr_uint16_t_Array_Front( Containment_Ptr_uint16_t_Array* a); Containment_Ptr_uint16_t Containment_Ptr_uint16_t_Array_Back( Containment_Ptr_uint16_t_Array* a); void Containment_Ptr_uint16_t_Array_Clear( Containment_Ptr_uint16_t_Array* a); void Containment_Ptr_uint16_t_Array_ShrinkToFit( Containment_Ptr_uint16_t_Array* a); void Containment_Ptr_uint16_t_Array_Resize( Containment_Ptr_uint16_t_Array* a, size_t length); void Containment_Ptr_uint16_t_Array_SetCapacity( Containment_Ptr_uint16_t_Array* a, size_t capacity ); void Containment_Ptr_uint16_t_Array_Reserve( Containment_Ptr_uint16_t_Array* a, size_t capacity); void Containment_Ptr_uint16_t_Array_Grow( Containment_Ptr_uint16_t_Array* a, size_t minCapacity); inline Containment_Ptr_uint16_t_Array Containment_Ptr_uint16_t_Array_Create(void) { Containment_Ptr_uint16_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_uint16_t_Array_Free( Containment_Ptr_uint16_t_Array* a ) { free(a->data); } inline Containment_Ptr_uint16_t Containment_Ptr_uint16_t_Array_Get( Containment_Ptr_uint16_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_uint16_t* Containment_Ptr_uint16_t_Array_GetPtr( Containment_Ptr_uint16_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_uint16_t_Array_Set( Containment_Ptr_uint16_t_Array* a, size_t index, Containment_Ptr_uint16_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_uint16_t_Array_Append( Containment_Ptr_uint16_t_Array* a, Containment_Ptr_uint16_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_uint16_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_uint16_t_Array_AppendMany( Containment_Ptr_uint16_t_Array* a, Containment_Ptr_uint16_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_uint16_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_uint16_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_uint16_t_Array_PopBack( Containment_Ptr_uint16_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_uint16_t_Array_Length( Containment_Ptr_uint16_t_Array* a) { return a->length; } inline size_t Containment_Ptr_uint16_t_Array_Capacity(Containment_Ptr_uint16_t_Array* a) { return a->capacity; } inline Containment_Ptr_uint16_t * Containment_Ptr_uint16_t_Array_Begin(Containment_Ptr_uint16_t_Array* a) { return a->data; } inline Containment_Ptr_uint16_t * Containment_Ptr_uint16_t_Array_End(Containment_Ptr_uint16_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_uint16_t Containment_Ptr_uint16_t_Array_Front(Containment_Ptr_uint16_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint16_t_Array_Begin(a) ); } inline Containment_Ptr_uint16_t Containment_Ptr_uint16_t_Array_Back(Containment_Ptr_uint16_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint16_t_Array_End(a) - 1 ); } inline void Containment_Ptr_uint16_t_Array_Clear(Containment_Ptr_uint16_t_Array* a) { Containment_Ptr_uint16_t_Array_Resize(a, 0); } inline void Containment_Ptr_uint16_t_Array_ShrinkToFit(Containment_Ptr_uint16_t_Array* a) { Containment_Ptr_uint16_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_uint16_t_Array_Resize(Containment_Ptr_uint16_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_uint16_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_uint16_t_Array_SetCapacity( Containment_Ptr_uint16_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_uint16_t_Array_Resize(a, capacity); Containment_Ptr_uint16_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_uint16_t * ) malloc( capacity * sizeof( Containment_Ptr_uint16_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_uint16_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_uint16_t_Array_Reserve( Containment_Ptr_uint16_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_uint16_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_uint16_t_Array_Grow( Containment_Ptr_uint16_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_uint16_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; uint16_t value; } uint16_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; uint16_t_Hashmap_Entry * data; } uint16_t_Hashmap_Entry_Array ; uint16_t_Hashmap_Entry_Array uint16_t_Hashmap_Entry_Array_Create(void); void uint16_t_Hashmap_Entry_Array_Free( uint16_t_Hashmap_Entry_Array* a ); uint16_t_Hashmap_Entry uint16_t_Hashmap_Entry_Array_Get( uint16_t_Hashmap_Entry_Array* a, size_t index); uint16_t_Hashmap_Entry* uint16_t_Hashmap_Entry_Array_GetPtr( uint16_t_Hashmap_Entry_Array* a, size_t index); void uint16_t_Hashmap_Entry_Array_Set( uint16_t_Hashmap_Entry_Array* a, size_t index, uint16_t_Hashmap_Entry value ); size_t uint16_t_Hashmap_Entry_Array_Append( uint16_t_Hashmap_Entry_Array* a, uint16_t_Hashmap_Entry item); size_t uint16_t_Hashmap_Entry_Array_AppendMany( uint16_t_Hashmap_Entry_Array* a, uint16_t_Hashmap_Entry * items, size_t count); void uint16_t_Hashmap_Entry_Array_PopBack( uint16_t_Hashmap_Entry_Array* a); size_t uint16_t_Hashmap_Entry_Array_Length( uint16_t_Hashmap_Entry_Array* a); uint16_t_Hashmap_Entry * uint16_t_Hashmap_Entry_Array_Begin( uint16_t_Hashmap_Entry_Array* a); uint16_t_Hashmap_Entry * uint16_t_Hashmap_Entry_Array_End( uint16_t_Hashmap_Entry_Array* a); uint16_t_Hashmap_Entry uint16_t_Hashmap_Entry_Array_Front( uint16_t_Hashmap_Entry_Array* a); uint16_t_Hashmap_Entry uint16_t_Hashmap_Entry_Array_Back( uint16_t_Hashmap_Entry_Array* a); void uint16_t_Hashmap_Entry_Array_Clear( uint16_t_Hashmap_Entry_Array* a); void uint16_t_Hashmap_Entry_Array_ShrinkToFit( uint16_t_Hashmap_Entry_Array* a); void uint16_t_Hashmap_Entry_Array_Resize( uint16_t_Hashmap_Entry_Array* a, size_t length); void uint16_t_Hashmap_Entry_Array_SetCapacity( uint16_t_Hashmap_Entry_Array* a, size_t capacity ); void uint16_t_Hashmap_Entry_Array_Reserve( uint16_t_Hashmap_Entry_Array* a, size_t capacity); void uint16_t_Hashmap_Entry_Array_Grow( uint16_t_Hashmap_Entry_Array* a, size_t minCapacity); inline uint16_t_Hashmap_Entry_Array uint16_t_Hashmap_Entry_Array_Create(void) { uint16_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint16_t_Hashmap_Entry_Array_Free( uint16_t_Hashmap_Entry_Array* a ) { free(a->data); } inline uint16_t_Hashmap_Entry uint16_t_Hashmap_Entry_Array_Get( uint16_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline uint16_t_Hashmap_Entry* uint16_t_Hashmap_Entry_Array_GetPtr( uint16_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void uint16_t_Hashmap_Entry_Array_Set( uint16_t_Hashmap_Entry_Array* a, size_t index, uint16_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t uint16_t_Hashmap_Entry_Array_Append( uint16_t_Hashmap_Entry_Array* a, uint16_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) uint16_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint16_t_Hashmap_Entry_Array_AppendMany( uint16_t_Hashmap_Entry_Array* a, uint16_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) uint16_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint16_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void uint16_t_Hashmap_Entry_Array_PopBack( uint16_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint16_t_Hashmap_Entry_Array_Length( uint16_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t uint16_t_Hashmap_Entry_Array_Capacity(uint16_t_Hashmap_Entry_Array* a) { return a->capacity; } inline uint16_t_Hashmap_Entry * uint16_t_Hashmap_Entry_Array_Begin(uint16_t_Hashmap_Entry_Array* a) { return a->data; } inline uint16_t_Hashmap_Entry * uint16_t_Hashmap_Entry_Array_End(uint16_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline uint16_t_Hashmap_Entry uint16_t_Hashmap_Entry_Array_Front(uint16_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint16_t_Hashmap_Entry_Array_Begin(a) ); } inline uint16_t_Hashmap_Entry uint16_t_Hashmap_Entry_Array_Back(uint16_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint16_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void uint16_t_Hashmap_Entry_Array_Clear(uint16_t_Hashmap_Entry_Array* a) { uint16_t_Hashmap_Entry_Array_Resize(a, 0); } inline void uint16_t_Hashmap_Entry_Array_ShrinkToFit(uint16_t_Hashmap_Entry_Array* a) { uint16_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void uint16_t_Hashmap_Entry_Array_Resize(uint16_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) uint16_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void uint16_t_Hashmap_Entry_Array_SetCapacity( uint16_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint16_t_Hashmap_Entry_Array_Resize(a, capacity); uint16_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( uint16_t_Hashmap_Entry * ) malloc( capacity * sizeof( uint16_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( uint16_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint16_t_Hashmap_Entry_Array_Reserve( uint16_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) uint16_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void uint16_t_Hashmap_Entry_Array_Grow( uint16_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint16_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; uint16_t_Hashmap_Entry_Array data; } uint16_t_Hashmap; uint16_t_Hashmap uint16_t_Hashmap_Create(void); void uint16_t_Hashmap_Free( uint16_t_Hashmap* h); size_t uint16_t_Hashmap_Impl_AddEntry( uint16_t_Hashmap* h, uint64_t key); void uint16_t_Hashmap_Impl_Erase( uint16_t_Hashmap* h, FindResult* fr); FindResult uint16_t_Hashmap_Impl_FindByKey( uint16_t_Hashmap* h, uint64_t key); FindResult uint16_t_Hashmap_Impl_FindByEntry( uint16_t_Hashmap* h, uint16_t_Hashmap_Entry* e); size_t uint16_t_Hashmap_Impl_Make( uint16_t_Hashmap* h, uint64_t key); void uint16_t_Hashmap_Impl_FindAndErase(uint16_t_Hashmap* h, uint64_t key); size_t uint16_t_Hashmap_Impl_FindOrFail(uint16_t_Hashmap* h, uint64_t key); size_t uint16_t_Hashmap_Impl_FindOrMake( uint16_t_Hashmap* h, uint64_t key); void uint16_t_Hashmap_Impl_Rehash( uint16_t_Hashmap* h, size_t newCapacity); void uint16_t_Hashmap_Impl_Grow( uint16_t_Hashmap* h); char uint16_t_Hashmap_Impl_Full( uint16_t_Hashmap* h); char uint16_t_Hashmap_Has( uint16_t_Hashmap* h, uint64_t key); uint16_t uint16_t_Hashmap_Get( uint16_t_Hashmap* h, uint64_t key, uint16_t defaultValue ); uint16_t * uint16_t_Hashmap_GetPtr( uint16_t_Hashmap* h, uint64_t key, uint16_t * defaultValue ); size_t uint16_t_Hashmap_Set( uint16_t_Hashmap* h, uint64_t key, uint16_t value ); size_t uint16_t_Hashmap_SetPtr( uint16_t_Hashmap* h, uint64_t key, uint16_t* value ); void uint16_t_Hashmap_Remove( uint16_t_Hashmap* h, uint64_t key ); void uint16_t_Hashmap_Reserve( uint16_t_Hashmap* h, size_t capacity ); void uint16_t_Hashmap_Clear( uint16_t_Hashmap* h ); void uint16_t_Hashmap_Multi_Get( uint16_t_Hashmap* h, uint64_t key, uint16_t_Array * items ); void uint16_t_Hashmap_Multi_GetPtrs( uint16_t_Hashmap* h, uint64_t key, Containment_Ptr_uint16_t_Array * items ); size_t uint16_t_Hashmap_Multi_Count( uint16_t_Hashmap* h, uint64_t key ); void uint16_t_Hashmap_Multi_Insert( uint16_t_Hashmap* h, uint64_t key, uint16_t value ); void uint16_t_Hashmap_Multi_InsertMany( uint16_t_Hashmap* h, uint64_t key, uint16_t * values, size_t count ); uint16_t_Hashmap_Entry* uint16_t_Hashmap_Multi_FindFirst( uint16_t_Hashmap* h, uint64_t key); uint16_t_Hashmap_Entry* uint16_t_Hashmap_Multi_FindNext( uint16_t_Hashmap* h, uint16_t_Hashmap_Entry* e); void uint16_t_Hashmap_Multi_Remove( uint16_t_Hashmap* h, uint16_t_Hashmap_Entry* e); void uint16_t_Hashmap_Multi_RemoveAll(uint16_t_Hashmap* h, uint64_t key); inline uint16_t_Hashmap uint16_t_Hashmap_Create(void) { uint16_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = uint16_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void uint16_t_Hashmap_Free( uint16_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); uint16_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t uint16_t_Hashmap_Impl_AddEntry( uint16_t_Hashmap* h, uint64_t key) { uint16_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; uint16_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void uint16_t_Hashmap_Impl_Erase( uint16_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; uint16_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = uint16_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult uint16_t_Hashmap_Impl_FindByKey( uint16_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult uint16_t_Hashmap_Impl_FindByEntry( uint16_t_Hashmap* h, uint16_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t uint16_t_Hashmap_Impl_Make( uint16_t_Hashmap* h, uint64_t key) { FindResult fr = uint16_t_Hashmap_Impl_FindByKey(h, key); size_t index = uint16_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void uint16_t_Hashmap_Impl_FindAndErase( uint16_t_Hashmap* h, uint64_t key) { FindResult fr = uint16_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) uint16_t_Hashmap_Impl_Erase(h, &fr); } inline size_t uint16_t_Hashmap_Impl_FindOrFail( uint16_t_Hashmap* h, uint64_t key) { return uint16_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t uint16_t_Hashmap_Impl_FindOrMake( uint16_t_Hashmap* h, uint64_t key) { FindResult fr = uint16_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = uint16_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void uint16_t_Hashmap_Impl_Rehash( uint16_t_Hashmap* h, size_t newCapacity) { uint16_t_Hashmap nh = uint16_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; uint16_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { uint16_t_Hashmap_Entry* e = &h->data.data[i]; uint16_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = uint16_t_Hashmap_Create(); } inline void uint16_t_Hashmap_Impl_Grow( uint16_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; uint16_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char uint16_t_Hashmap_Impl_Full( uint16_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char uint16_t_Hashmap_Has( uint16_t_Hashmap* h, uint64_t key) { return uint16_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline uint16_t uint16_t_Hashmap_Get( uint16_t_Hashmap* h, uint64_t key, uint16_t defaultValue ) { size_t index = uint16_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline uint16_t * uint16_t_Hashmap_GetPtr( uint16_t_Hashmap* h, uint64_t key, uint16_t * defaultValue ) { size_t index = uint16_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t uint16_t_Hashmap_Set( uint16_t_Hashmap* h, uint64_t key, uint16_t value ) { if (h->hashes.length == 0) uint16_t_Hashmap_Impl_Grow(h); size_t index = uint16_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (uint16_t_Hashmap_Impl_Full(h)) uint16_t_Hashmap_Impl_Grow(h); return index; } inline size_t uint16_t_Hashmap_SetPtr( uint16_t_Hashmap* h, uint64_t key, uint16_t* value ) { if (h->hashes.length == 0) uint16_t_Hashmap_Impl_Grow(h); size_t index = uint16_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (uint16_t_Hashmap_Impl_Full(h)) uint16_t_Hashmap_Impl_Grow(h); return index; } inline void uint16_t_Hashmap_Remove( uint16_t_Hashmap* h, uint64_t key ) { uint16_t_Hashmap_Impl_FindAndErase(h, key); } inline void uint16_t_Hashmap_Reserve( uint16_t_Hashmap* h, size_t capacity ) { uint16_t_Hashmap_Impl_Rehash(h, capacity); } inline void uint16_t_Hashmap_Clear( uint16_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); uint16_t_Hashmap_Entry_Array_Clear(&h->data); } inline void uint16_t_Hashmap_Multi_Get( uint16_t_Hashmap* h, uint64_t key, uint16_t_Array * items ) { uint16_t_Hashmap_Entry* e = uint16_t_Hashmap_Multi_FindFirst(h, key); while (e) { uint16_t_Array_Append(items, e->value); e = uint16_t_Hashmap_Multi_FindNext(h, e); } } inline void uint16_t_Hashmap_Multi_GetPtrs( uint16_t_Hashmap* h, uint64_t key, Containment_Ptr_uint16_t_Array * items ) { uint16_t_Hashmap_Entry* e = uint16_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_uint16_t_Array_Append(items, & (e->value) ); e = uint16_t_Hashmap_Multi_FindNext(h, e); } } inline size_t uint16_t_Hashmap_Multi_Count( uint16_t_Hashmap* h, uint64_t key ) { uint16_t_Hashmap_Entry* e = uint16_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = uint16_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void uint16_t_Hashmap_Multi_Insert( uint16_t_Hashmap* h, uint64_t key, uint16_t value ) { if (h->hashes.length == 0) uint16_t_Hashmap_Impl_Grow(h); size_t next = uint16_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (uint16_t_Hashmap_Impl_Full(h)) uint16_t_Hashmap_Impl_Grow(h); } inline void uint16_t_Hashmap_Multi_InsertMany( uint16_t_Hashmap* h, uint64_t key, uint16_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { uint16_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline uint16_t_Hashmap_Entry* uint16_t_Hashmap_Multi_FindFirst( uint16_t_Hashmap* h, uint64_t key) { size_t index = uint16_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline uint16_t_Hashmap_Entry* uint16_t_Hashmap_Multi_FindNext( uint16_t_Hashmap* h, uint16_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void uint16_t_Hashmap_Multi_Remove( uint16_t_Hashmap* h, uint16_t_Hashmap_Entry* e) { FindResult fr = uint16_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) uint16_t_Hashmap_Impl_Erase(h, &fr); } inline void uint16_t_Hashmap_Multi_RemoveAll(uint16_t_Hashmap* h, uint64_t key) { while (uint16_t_Hashmap_Has(h, key)) uint16_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; int32_t * data; } int32_t_Array ; int32_t_Array int32_t_Array_Create(void); void int32_t_Array_Free( int32_t_Array* a ); int32_t int32_t_Array_Get( int32_t_Array* a, size_t index); int32_t* int32_t_Array_GetPtr( int32_t_Array* a, size_t index); void int32_t_Array_Set( int32_t_Array* a, size_t index, int32_t value ); size_t int32_t_Array_Append( int32_t_Array* a, int32_t item); size_t int32_t_Array_AppendMany( int32_t_Array* a, int32_t * items, size_t count); void int32_t_Array_PopBack( int32_t_Array* a); size_t int32_t_Array_Length( int32_t_Array* a); int32_t * int32_t_Array_Begin( int32_t_Array* a); int32_t * int32_t_Array_End( int32_t_Array* a); int32_t int32_t_Array_Front( int32_t_Array* a); int32_t int32_t_Array_Back( int32_t_Array* a); void int32_t_Array_Clear( int32_t_Array* a); void int32_t_Array_ShrinkToFit( int32_t_Array* a); void int32_t_Array_Resize( int32_t_Array* a, size_t length); void int32_t_Array_SetCapacity( int32_t_Array* a, size_t capacity ); void int32_t_Array_Reserve( int32_t_Array* a, size_t capacity); void int32_t_Array_Grow( int32_t_Array* a, size_t minCapacity); inline int32_t_Array int32_t_Array_Create(void) { int32_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int32_t_Array_Free( int32_t_Array* a ) { free(a->data); } inline int32_t int32_t_Array_Get( int32_t_Array* a, size_t index) { return a->data[index]; } inline int32_t* int32_t_Array_GetPtr( int32_t_Array* a, size_t index) { return & (a->data[index]); } inline void int32_t_Array_Set( int32_t_Array* a, size_t index, int32_t value ) { a->data[index] = value; } inline size_t int32_t_Array_Append( int32_t_Array* a, int32_t item) { if (a->length + 1 > a->capacity) int32_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int32_t_Array_AppendMany( int32_t_Array* a, int32_t * items, size_t count) { if (a->capacity <= a->length + count) int32_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int32_t ) ); a->length += count; return a->length; }inline void int32_t_Array_PopBack( int32_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t int32_t_Array_Length( int32_t_Array* a) { return a->length; } inline size_t int32_t_Array_Capacity(int32_t_Array* a) { return a->capacity; } inline int32_t * int32_t_Array_Begin(int32_t_Array* a) { return a->data; } inline int32_t * int32_t_Array_End(int32_t_Array* a) { return a->data + a->length; } inline int32_t int32_t_Array_Front(int32_t_Array* a) { assert(a->length > 0); return * ( int32_t_Array_Begin(a) ); } inline int32_t int32_t_Array_Back(int32_t_Array* a) { assert(a->length > 0); return * ( int32_t_Array_End(a) - 1 ); } inline void int32_t_Array_Clear(int32_t_Array* a) { int32_t_Array_Resize(a, 0); } inline void int32_t_Array_ShrinkToFit(int32_t_Array* a) { int32_t_Array_SetCapacity(a, a->length); } inline void int32_t_Array_Resize(int32_t_Array* a, size_t length) { if (length > a->capacity) int32_t_Array_Grow(a, length); a->length = length; } inline void int32_t_Array_SetCapacity( int32_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int32_t_Array_Resize(a, capacity); int32_t * data = NULL; if (capacity > 0) { data = ( int32_t * ) malloc( capacity * sizeof( int32_t ) ); memcpy(data, a->data, a->length * sizeof( int32_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int32_t_Array_Reserve( int32_t_Array* a, size_t capacity) { if (capacity > a->capacity) int32_t_Array_SetCapacity(a, capacity); } inline void int32_t_Array_Grow( int32_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int32_t_Array_SetCapacity(a, capacity); } typedef int32_t *Containment_Ptr_int32_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_int32_t * data; } Containment_Ptr_int32_t_Array ; Containment_Ptr_int32_t_Array Containment_Ptr_int32_t_Array_Create(void); void Containment_Ptr_int32_t_Array_Free( Containment_Ptr_int32_t_Array* a ); Containment_Ptr_int32_t Containment_Ptr_int32_t_Array_Get( Containment_Ptr_int32_t_Array* a, size_t index); Containment_Ptr_int32_t* Containment_Ptr_int32_t_Array_GetPtr( Containment_Ptr_int32_t_Array* a, size_t index); void Containment_Ptr_int32_t_Array_Set( Containment_Ptr_int32_t_Array* a, size_t index, Containment_Ptr_int32_t value ); size_t Containment_Ptr_int32_t_Array_Append( Containment_Ptr_int32_t_Array* a, Containment_Ptr_int32_t item); size_t Containment_Ptr_int32_t_Array_AppendMany( Containment_Ptr_int32_t_Array* a, Containment_Ptr_int32_t * items, size_t count); void Containment_Ptr_int32_t_Array_PopBack( Containment_Ptr_int32_t_Array* a); size_t Containment_Ptr_int32_t_Array_Length( Containment_Ptr_int32_t_Array* a); Containment_Ptr_int32_t * Containment_Ptr_int32_t_Array_Begin( Containment_Ptr_int32_t_Array* a); Containment_Ptr_int32_t * Containment_Ptr_int32_t_Array_End( Containment_Ptr_int32_t_Array* a); Containment_Ptr_int32_t Containment_Ptr_int32_t_Array_Front( Containment_Ptr_int32_t_Array* a); Containment_Ptr_int32_t Containment_Ptr_int32_t_Array_Back( Containment_Ptr_int32_t_Array* a); void Containment_Ptr_int32_t_Array_Clear( Containment_Ptr_int32_t_Array* a); void Containment_Ptr_int32_t_Array_ShrinkToFit( Containment_Ptr_int32_t_Array* a); void Containment_Ptr_int32_t_Array_Resize( Containment_Ptr_int32_t_Array* a, size_t length); void Containment_Ptr_int32_t_Array_SetCapacity( Containment_Ptr_int32_t_Array* a, size_t capacity ); void Containment_Ptr_int32_t_Array_Reserve( Containment_Ptr_int32_t_Array* a, size_t capacity); void Containment_Ptr_int32_t_Array_Grow( Containment_Ptr_int32_t_Array* a, size_t minCapacity); inline Containment_Ptr_int32_t_Array Containment_Ptr_int32_t_Array_Create(void) { Containment_Ptr_int32_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_int32_t_Array_Free( Containment_Ptr_int32_t_Array* a ) { free(a->data); } inline Containment_Ptr_int32_t Containment_Ptr_int32_t_Array_Get( Containment_Ptr_int32_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_int32_t* Containment_Ptr_int32_t_Array_GetPtr( Containment_Ptr_int32_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_int32_t_Array_Set( Containment_Ptr_int32_t_Array* a, size_t index, Containment_Ptr_int32_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_int32_t_Array_Append( Containment_Ptr_int32_t_Array* a, Containment_Ptr_int32_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_int32_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_int32_t_Array_AppendMany( Containment_Ptr_int32_t_Array* a, Containment_Ptr_int32_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_int32_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_int32_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_int32_t_Array_PopBack( Containment_Ptr_int32_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_int32_t_Array_Length( Containment_Ptr_int32_t_Array* a) { return a->length; } inline size_t Containment_Ptr_int32_t_Array_Capacity(Containment_Ptr_int32_t_Array* a) { return a->capacity; } inline Containment_Ptr_int32_t * Containment_Ptr_int32_t_Array_Begin(Containment_Ptr_int32_t_Array* a) { return a->data; } inline Containment_Ptr_int32_t * Containment_Ptr_int32_t_Array_End(Containment_Ptr_int32_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_int32_t Containment_Ptr_int32_t_Array_Front(Containment_Ptr_int32_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int32_t_Array_Begin(a) ); } inline Containment_Ptr_int32_t Containment_Ptr_int32_t_Array_Back(Containment_Ptr_int32_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int32_t_Array_End(a) - 1 ); } inline void Containment_Ptr_int32_t_Array_Clear(Containment_Ptr_int32_t_Array* a) { Containment_Ptr_int32_t_Array_Resize(a, 0); } inline void Containment_Ptr_int32_t_Array_ShrinkToFit(Containment_Ptr_int32_t_Array* a) { Containment_Ptr_int32_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_int32_t_Array_Resize(Containment_Ptr_int32_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_int32_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_int32_t_Array_SetCapacity( Containment_Ptr_int32_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_int32_t_Array_Resize(a, capacity); Containment_Ptr_int32_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_int32_t * ) malloc( capacity * sizeof( Containment_Ptr_int32_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_int32_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_int32_t_Array_Reserve( Containment_Ptr_int32_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_int32_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_int32_t_Array_Grow( Containment_Ptr_int32_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_int32_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; int32_t value; } int32_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; int32_t_Hashmap_Entry * data; } int32_t_Hashmap_Entry_Array ; int32_t_Hashmap_Entry_Array int32_t_Hashmap_Entry_Array_Create(void); void int32_t_Hashmap_Entry_Array_Free( int32_t_Hashmap_Entry_Array* a ); int32_t_Hashmap_Entry int32_t_Hashmap_Entry_Array_Get( int32_t_Hashmap_Entry_Array* a, size_t index); int32_t_Hashmap_Entry* int32_t_Hashmap_Entry_Array_GetPtr( int32_t_Hashmap_Entry_Array* a, size_t index); void int32_t_Hashmap_Entry_Array_Set( int32_t_Hashmap_Entry_Array* a, size_t index, int32_t_Hashmap_Entry value ); size_t int32_t_Hashmap_Entry_Array_Append( int32_t_Hashmap_Entry_Array* a, int32_t_Hashmap_Entry item); size_t int32_t_Hashmap_Entry_Array_AppendMany( int32_t_Hashmap_Entry_Array* a, int32_t_Hashmap_Entry * items, size_t count); void int32_t_Hashmap_Entry_Array_PopBack( int32_t_Hashmap_Entry_Array* a); size_t int32_t_Hashmap_Entry_Array_Length( int32_t_Hashmap_Entry_Array* a); int32_t_Hashmap_Entry * int32_t_Hashmap_Entry_Array_Begin( int32_t_Hashmap_Entry_Array* a); int32_t_Hashmap_Entry * int32_t_Hashmap_Entry_Array_End( int32_t_Hashmap_Entry_Array* a); int32_t_Hashmap_Entry int32_t_Hashmap_Entry_Array_Front( int32_t_Hashmap_Entry_Array* a); int32_t_Hashmap_Entry int32_t_Hashmap_Entry_Array_Back( int32_t_Hashmap_Entry_Array* a); void int32_t_Hashmap_Entry_Array_Clear( int32_t_Hashmap_Entry_Array* a); void int32_t_Hashmap_Entry_Array_ShrinkToFit( int32_t_Hashmap_Entry_Array* a); void int32_t_Hashmap_Entry_Array_Resize( int32_t_Hashmap_Entry_Array* a, size_t length); void int32_t_Hashmap_Entry_Array_SetCapacity( int32_t_Hashmap_Entry_Array* a, size_t capacity ); void int32_t_Hashmap_Entry_Array_Reserve( int32_t_Hashmap_Entry_Array* a, size_t capacity); void int32_t_Hashmap_Entry_Array_Grow( int32_t_Hashmap_Entry_Array* a, size_t minCapacity); inline int32_t_Hashmap_Entry_Array int32_t_Hashmap_Entry_Array_Create(void) { int32_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int32_t_Hashmap_Entry_Array_Free( int32_t_Hashmap_Entry_Array* a ) { free(a->data); } inline int32_t_Hashmap_Entry int32_t_Hashmap_Entry_Array_Get( int32_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline int32_t_Hashmap_Entry* int32_t_Hashmap_Entry_Array_GetPtr( int32_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void int32_t_Hashmap_Entry_Array_Set( int32_t_Hashmap_Entry_Array* a, size_t index, int32_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t int32_t_Hashmap_Entry_Array_Append( int32_t_Hashmap_Entry_Array* a, int32_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) int32_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int32_t_Hashmap_Entry_Array_AppendMany( int32_t_Hashmap_Entry_Array* a, int32_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) int32_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int32_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void int32_t_Hashmap_Entry_Array_PopBack( int32_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t int32_t_Hashmap_Entry_Array_Length( int32_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t int32_t_Hashmap_Entry_Array_Capacity(int32_t_Hashmap_Entry_Array* a) { return a->capacity; } inline int32_t_Hashmap_Entry * int32_t_Hashmap_Entry_Array_Begin(int32_t_Hashmap_Entry_Array* a) { return a->data; } inline int32_t_Hashmap_Entry * int32_t_Hashmap_Entry_Array_End(int32_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline int32_t_Hashmap_Entry int32_t_Hashmap_Entry_Array_Front(int32_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int32_t_Hashmap_Entry_Array_Begin(a) ); } inline int32_t_Hashmap_Entry int32_t_Hashmap_Entry_Array_Back(int32_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int32_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void int32_t_Hashmap_Entry_Array_Clear(int32_t_Hashmap_Entry_Array* a) { int32_t_Hashmap_Entry_Array_Resize(a, 0); } inline void int32_t_Hashmap_Entry_Array_ShrinkToFit(int32_t_Hashmap_Entry_Array* a) { int32_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void int32_t_Hashmap_Entry_Array_Resize(int32_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) int32_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void int32_t_Hashmap_Entry_Array_SetCapacity( int32_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int32_t_Hashmap_Entry_Array_Resize(a, capacity); int32_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( int32_t_Hashmap_Entry * ) malloc( capacity * sizeof( int32_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( int32_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int32_t_Hashmap_Entry_Array_Reserve( int32_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) int32_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void int32_t_Hashmap_Entry_Array_Grow( int32_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int32_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; int32_t_Hashmap_Entry_Array data; } int32_t_Hashmap; int32_t_Hashmap int32_t_Hashmap_Create(void); void int32_t_Hashmap_Free( int32_t_Hashmap* h); size_t int32_t_Hashmap_Impl_AddEntry( int32_t_Hashmap* h, uint64_t key); void int32_t_Hashmap_Impl_Erase( int32_t_Hashmap* h, FindResult* fr); FindResult int32_t_Hashmap_Impl_FindByKey( int32_t_Hashmap* h, uint64_t key); FindResult int32_t_Hashmap_Impl_FindByEntry( int32_t_Hashmap* h, int32_t_Hashmap_Entry* e); size_t int32_t_Hashmap_Impl_Make( int32_t_Hashmap* h, uint64_t key); void int32_t_Hashmap_Impl_FindAndErase(int32_t_Hashmap* h, uint64_t key); size_t int32_t_Hashmap_Impl_FindOrFail(int32_t_Hashmap* h, uint64_t key); size_t int32_t_Hashmap_Impl_FindOrMake( int32_t_Hashmap* h, uint64_t key); void int32_t_Hashmap_Impl_Rehash( int32_t_Hashmap* h, size_t newCapacity); void int32_t_Hashmap_Impl_Grow( int32_t_Hashmap* h); char int32_t_Hashmap_Impl_Full( int32_t_Hashmap* h); char int32_t_Hashmap_Has( int32_t_Hashmap* h, uint64_t key); int32_t int32_t_Hashmap_Get( int32_t_Hashmap* h, uint64_t key, int32_t defaultValue ); int32_t * int32_t_Hashmap_GetPtr( int32_t_Hashmap* h, uint64_t key, int32_t * defaultValue ); size_t int32_t_Hashmap_Set( int32_t_Hashmap* h, uint64_t key, int32_t value ); size_t int32_t_Hashmap_SetPtr( int32_t_Hashmap* h, uint64_t key, int32_t* value ); void int32_t_Hashmap_Remove( int32_t_Hashmap* h, uint64_t key ); void int32_t_Hashmap_Reserve( int32_t_Hashmap* h, size_t capacity ); void int32_t_Hashmap_Clear( int32_t_Hashmap* h ); void int32_t_Hashmap_Multi_Get( int32_t_Hashmap* h, uint64_t key, int32_t_Array * items ); void int32_t_Hashmap_Multi_GetPtrs( int32_t_Hashmap* h, uint64_t key, Containment_Ptr_int32_t_Array * items ); size_t int32_t_Hashmap_Multi_Count( int32_t_Hashmap* h, uint64_t key ); void int32_t_Hashmap_Multi_Insert( int32_t_Hashmap* h, uint64_t key, int32_t value ); void int32_t_Hashmap_Multi_InsertMany( int32_t_Hashmap* h, uint64_t key, int32_t * values, size_t count ); int32_t_Hashmap_Entry* int32_t_Hashmap_Multi_FindFirst( int32_t_Hashmap* h, uint64_t key); int32_t_Hashmap_Entry* int32_t_Hashmap_Multi_FindNext( int32_t_Hashmap* h, int32_t_Hashmap_Entry* e); void int32_t_Hashmap_Multi_Remove( int32_t_Hashmap* h, int32_t_Hashmap_Entry* e); void int32_t_Hashmap_Multi_RemoveAll(int32_t_Hashmap* h, uint64_t key); inline int32_t_Hashmap int32_t_Hashmap_Create(void) { int32_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = int32_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void int32_t_Hashmap_Free( int32_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); int32_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t int32_t_Hashmap_Impl_AddEntry( int32_t_Hashmap* h, uint64_t key) { int32_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; int32_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void int32_t_Hashmap_Impl_Erase( int32_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; int32_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = int32_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult int32_t_Hashmap_Impl_FindByKey( int32_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult int32_t_Hashmap_Impl_FindByEntry( int32_t_Hashmap* h, int32_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t int32_t_Hashmap_Impl_Make( int32_t_Hashmap* h, uint64_t key) { FindResult fr = int32_t_Hashmap_Impl_FindByKey(h, key); size_t index = int32_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void int32_t_Hashmap_Impl_FindAndErase( int32_t_Hashmap* h, uint64_t key) { FindResult fr = int32_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) int32_t_Hashmap_Impl_Erase(h, &fr); } inline size_t int32_t_Hashmap_Impl_FindOrFail( int32_t_Hashmap* h, uint64_t key) { return int32_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t int32_t_Hashmap_Impl_FindOrMake( int32_t_Hashmap* h, uint64_t key) { FindResult fr = int32_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = int32_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void int32_t_Hashmap_Impl_Rehash( int32_t_Hashmap* h, size_t newCapacity) { int32_t_Hashmap nh = int32_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; int32_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { int32_t_Hashmap_Entry* e = &h->data.data[i]; int32_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = int32_t_Hashmap_Create(); } inline void int32_t_Hashmap_Impl_Grow( int32_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; int32_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char int32_t_Hashmap_Impl_Full( int32_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char int32_t_Hashmap_Has( int32_t_Hashmap* h, uint64_t key) { return int32_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline int32_t int32_t_Hashmap_Get( int32_t_Hashmap* h, uint64_t key, int32_t defaultValue ) { size_t index = int32_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline int32_t * int32_t_Hashmap_GetPtr( int32_t_Hashmap* h, uint64_t key, int32_t * defaultValue ) { size_t index = int32_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t int32_t_Hashmap_Set( int32_t_Hashmap* h, uint64_t key, int32_t value ) { if (h->hashes.length == 0) int32_t_Hashmap_Impl_Grow(h); size_t index = int32_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (int32_t_Hashmap_Impl_Full(h)) int32_t_Hashmap_Impl_Grow(h); return index; } inline size_t int32_t_Hashmap_SetPtr( int32_t_Hashmap* h, uint64_t key, int32_t* value ) { if (h->hashes.length == 0) int32_t_Hashmap_Impl_Grow(h); size_t index = int32_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (int32_t_Hashmap_Impl_Full(h)) int32_t_Hashmap_Impl_Grow(h); return index; } inline void int32_t_Hashmap_Remove( int32_t_Hashmap* h, uint64_t key ) { int32_t_Hashmap_Impl_FindAndErase(h, key); } inline void int32_t_Hashmap_Reserve( int32_t_Hashmap* h, size_t capacity ) { int32_t_Hashmap_Impl_Rehash(h, capacity); } inline void int32_t_Hashmap_Clear( int32_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); int32_t_Hashmap_Entry_Array_Clear(&h->data); } inline void int32_t_Hashmap_Multi_Get( int32_t_Hashmap* h, uint64_t key, int32_t_Array * items ) { int32_t_Hashmap_Entry* e = int32_t_Hashmap_Multi_FindFirst(h, key); while (e) { int32_t_Array_Append(items, e->value); e = int32_t_Hashmap_Multi_FindNext(h, e); } } inline void int32_t_Hashmap_Multi_GetPtrs( int32_t_Hashmap* h, uint64_t key, Containment_Ptr_int32_t_Array * items ) { int32_t_Hashmap_Entry* e = int32_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_int32_t_Array_Append(items, & (e->value) ); e = int32_t_Hashmap_Multi_FindNext(h, e); } } inline size_t int32_t_Hashmap_Multi_Count( int32_t_Hashmap* h, uint64_t key ) { int32_t_Hashmap_Entry* e = int32_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = int32_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void int32_t_Hashmap_Multi_Insert( int32_t_Hashmap* h, uint64_t key, int32_t value ) { if (h->hashes.length == 0) int32_t_Hashmap_Impl_Grow(h); size_t next = int32_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (int32_t_Hashmap_Impl_Full(h)) int32_t_Hashmap_Impl_Grow(h); } inline void int32_t_Hashmap_Multi_InsertMany( int32_t_Hashmap* h, uint64_t key, int32_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { int32_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline int32_t_Hashmap_Entry* int32_t_Hashmap_Multi_FindFirst( int32_t_Hashmap* h, uint64_t key) { size_t index = int32_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline int32_t_Hashmap_Entry* int32_t_Hashmap_Multi_FindNext( int32_t_Hashmap* h, int32_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void int32_t_Hashmap_Multi_Remove( int32_t_Hashmap* h, int32_t_Hashmap_Entry* e) { FindResult fr = int32_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) int32_t_Hashmap_Impl_Erase(h, &fr); } inline void int32_t_Hashmap_Multi_RemoveAll(int32_t_Hashmap* h, uint64_t key) { while (int32_t_Hashmap_Has(h, key)) int32_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; uint32_t * data; } uint32_t_Array ; uint32_t_Array uint32_t_Array_Create(void); void uint32_t_Array_Free( uint32_t_Array* a ); uint32_t uint32_t_Array_Get( uint32_t_Array* a, size_t index); uint32_t* uint32_t_Array_GetPtr( uint32_t_Array* a, size_t index); void uint32_t_Array_Set( uint32_t_Array* a, size_t index, uint32_t value ); size_t uint32_t_Array_Append( uint32_t_Array* a, uint32_t item); size_t uint32_t_Array_AppendMany( uint32_t_Array* a, uint32_t * items, size_t count); void uint32_t_Array_PopBack( uint32_t_Array* a); size_t uint32_t_Array_Length( uint32_t_Array* a); uint32_t * uint32_t_Array_Begin( uint32_t_Array* a); uint32_t * uint32_t_Array_End( uint32_t_Array* a); uint32_t uint32_t_Array_Front( uint32_t_Array* a); uint32_t uint32_t_Array_Back( uint32_t_Array* a); void uint32_t_Array_Clear( uint32_t_Array* a); void uint32_t_Array_ShrinkToFit( uint32_t_Array* a); void uint32_t_Array_Resize( uint32_t_Array* a, size_t length); void uint32_t_Array_SetCapacity( uint32_t_Array* a, size_t capacity ); void uint32_t_Array_Reserve( uint32_t_Array* a, size_t capacity); void uint32_t_Array_Grow( uint32_t_Array* a, size_t minCapacity); inline uint32_t_Array uint32_t_Array_Create(void) { uint32_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint32_t_Array_Free( uint32_t_Array* a ) { free(a->data); } inline uint32_t uint32_t_Array_Get( uint32_t_Array* a, size_t index) { return a->data[index]; } inline uint32_t* uint32_t_Array_GetPtr( uint32_t_Array* a, size_t index) { return & (a->data[index]); } inline void uint32_t_Array_Set( uint32_t_Array* a, size_t index, uint32_t value ) { a->data[index] = value; } inline size_t uint32_t_Array_Append( uint32_t_Array* a, uint32_t item) { if (a->length + 1 > a->capacity) uint32_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint32_t_Array_AppendMany( uint32_t_Array* a, uint32_t * items, size_t count) { if (a->capacity <= a->length + count) uint32_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint32_t ) ); a->length += count; return a->length; }inline void uint32_t_Array_PopBack( uint32_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint32_t_Array_Length( uint32_t_Array* a) { return a->length; } inline size_t uint32_t_Array_Capacity(uint32_t_Array* a) { return a->capacity; } inline uint32_t * uint32_t_Array_Begin(uint32_t_Array* a) { return a->data; } inline uint32_t * uint32_t_Array_End(uint32_t_Array* a) { return a->data + a->length; } inline uint32_t uint32_t_Array_Front(uint32_t_Array* a) { assert(a->length > 0); return * ( uint32_t_Array_Begin(a) ); } inline uint32_t uint32_t_Array_Back(uint32_t_Array* a) { assert(a->length > 0); return * ( uint32_t_Array_End(a) - 1 ); } inline void uint32_t_Array_Clear(uint32_t_Array* a) { uint32_t_Array_Resize(a, 0); } inline void uint32_t_Array_ShrinkToFit(uint32_t_Array* a) { uint32_t_Array_SetCapacity(a, a->length); } inline void uint32_t_Array_Resize(uint32_t_Array* a, size_t length) { if (length > a->capacity) uint32_t_Array_Grow(a, length); a->length = length; } inline void uint32_t_Array_SetCapacity( uint32_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint32_t_Array_Resize(a, capacity); uint32_t * data = NULL; if (capacity > 0) { data = ( uint32_t * ) malloc( capacity * sizeof( uint32_t ) ); memcpy(data, a->data, a->length * sizeof( uint32_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint32_t_Array_Reserve( uint32_t_Array* a, size_t capacity) { if (capacity > a->capacity) uint32_t_Array_SetCapacity(a, capacity); } inline void uint32_t_Array_Grow( uint32_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint32_t_Array_SetCapacity(a, capacity); } typedef uint32_t *Containment_Ptr_uint32_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_uint32_t * data; } Containment_Ptr_uint32_t_Array ; Containment_Ptr_uint32_t_Array Containment_Ptr_uint32_t_Array_Create(void); void Containment_Ptr_uint32_t_Array_Free( Containment_Ptr_uint32_t_Array* a ); Containment_Ptr_uint32_t Containment_Ptr_uint32_t_Array_Get( Containment_Ptr_uint32_t_Array* a, size_t index); Containment_Ptr_uint32_t* Containment_Ptr_uint32_t_Array_GetPtr( Containment_Ptr_uint32_t_Array* a, size_t index); void Containment_Ptr_uint32_t_Array_Set( Containment_Ptr_uint32_t_Array* a, size_t index, Containment_Ptr_uint32_t value ); size_t Containment_Ptr_uint32_t_Array_Append( Containment_Ptr_uint32_t_Array* a, Containment_Ptr_uint32_t item); size_t Containment_Ptr_uint32_t_Array_AppendMany( Containment_Ptr_uint32_t_Array* a, Containment_Ptr_uint32_t * items, size_t count); void Containment_Ptr_uint32_t_Array_PopBack( Containment_Ptr_uint32_t_Array* a); size_t Containment_Ptr_uint32_t_Array_Length( Containment_Ptr_uint32_t_Array* a); Containment_Ptr_uint32_t * Containment_Ptr_uint32_t_Array_Begin( Containment_Ptr_uint32_t_Array* a); Containment_Ptr_uint32_t * Containment_Ptr_uint32_t_Array_End( Containment_Ptr_uint32_t_Array* a); Containment_Ptr_uint32_t Containment_Ptr_uint32_t_Array_Front( Containment_Ptr_uint32_t_Array* a); Containment_Ptr_uint32_t Containment_Ptr_uint32_t_Array_Back( Containment_Ptr_uint32_t_Array* a); void Containment_Ptr_uint32_t_Array_Clear( Containment_Ptr_uint32_t_Array* a); void Containment_Ptr_uint32_t_Array_ShrinkToFit( Containment_Ptr_uint32_t_Array* a); void Containment_Ptr_uint32_t_Array_Resize( Containment_Ptr_uint32_t_Array* a, size_t length); void Containment_Ptr_uint32_t_Array_SetCapacity( Containment_Ptr_uint32_t_Array* a, size_t capacity ); void Containment_Ptr_uint32_t_Array_Reserve( Containment_Ptr_uint32_t_Array* a, size_t capacity); void Containment_Ptr_uint32_t_Array_Grow( Containment_Ptr_uint32_t_Array* a, size_t minCapacity); inline Containment_Ptr_uint32_t_Array Containment_Ptr_uint32_t_Array_Create(void) { Containment_Ptr_uint32_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_uint32_t_Array_Free( Containment_Ptr_uint32_t_Array* a ) { free(a->data); } inline Containment_Ptr_uint32_t Containment_Ptr_uint32_t_Array_Get( Containment_Ptr_uint32_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_uint32_t* Containment_Ptr_uint32_t_Array_GetPtr( Containment_Ptr_uint32_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_uint32_t_Array_Set( Containment_Ptr_uint32_t_Array* a, size_t index, Containment_Ptr_uint32_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_uint32_t_Array_Append( Containment_Ptr_uint32_t_Array* a, Containment_Ptr_uint32_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_uint32_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_uint32_t_Array_AppendMany( Containment_Ptr_uint32_t_Array* a, Containment_Ptr_uint32_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_uint32_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_uint32_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_uint32_t_Array_PopBack( Containment_Ptr_uint32_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_uint32_t_Array_Length( Containment_Ptr_uint32_t_Array* a) { return a->length; } inline size_t Containment_Ptr_uint32_t_Array_Capacity(Containment_Ptr_uint32_t_Array* a) { return a->capacity; } inline Containment_Ptr_uint32_t * Containment_Ptr_uint32_t_Array_Begin(Containment_Ptr_uint32_t_Array* a) { return a->data; } inline Containment_Ptr_uint32_t * Containment_Ptr_uint32_t_Array_End(Containment_Ptr_uint32_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_uint32_t Containment_Ptr_uint32_t_Array_Front(Containment_Ptr_uint32_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint32_t_Array_Begin(a) ); } inline Containment_Ptr_uint32_t Containment_Ptr_uint32_t_Array_Back(Containment_Ptr_uint32_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint32_t_Array_End(a) - 1 ); } inline void Containment_Ptr_uint32_t_Array_Clear(Containment_Ptr_uint32_t_Array* a) { Containment_Ptr_uint32_t_Array_Resize(a, 0); } inline void Containment_Ptr_uint32_t_Array_ShrinkToFit(Containment_Ptr_uint32_t_Array* a) { Containment_Ptr_uint32_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_uint32_t_Array_Resize(Containment_Ptr_uint32_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_uint32_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_uint32_t_Array_SetCapacity( Containment_Ptr_uint32_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_uint32_t_Array_Resize(a, capacity); Containment_Ptr_uint32_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_uint32_t * ) malloc( capacity * sizeof( Containment_Ptr_uint32_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_uint32_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_uint32_t_Array_Reserve( Containment_Ptr_uint32_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_uint32_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_uint32_t_Array_Grow( Containment_Ptr_uint32_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_uint32_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; uint32_t value; } uint32_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; uint32_t_Hashmap_Entry * data; } uint32_t_Hashmap_Entry_Array ; uint32_t_Hashmap_Entry_Array uint32_t_Hashmap_Entry_Array_Create(void); void uint32_t_Hashmap_Entry_Array_Free( uint32_t_Hashmap_Entry_Array* a ); uint32_t_Hashmap_Entry uint32_t_Hashmap_Entry_Array_Get( uint32_t_Hashmap_Entry_Array* a, size_t index); uint32_t_Hashmap_Entry* uint32_t_Hashmap_Entry_Array_GetPtr( uint32_t_Hashmap_Entry_Array* a, size_t index); void uint32_t_Hashmap_Entry_Array_Set( uint32_t_Hashmap_Entry_Array* a, size_t index, uint32_t_Hashmap_Entry value ); size_t uint32_t_Hashmap_Entry_Array_Append( uint32_t_Hashmap_Entry_Array* a, uint32_t_Hashmap_Entry item); size_t uint32_t_Hashmap_Entry_Array_AppendMany( uint32_t_Hashmap_Entry_Array* a, uint32_t_Hashmap_Entry * items, size_t count); void uint32_t_Hashmap_Entry_Array_PopBack( uint32_t_Hashmap_Entry_Array* a); size_t uint32_t_Hashmap_Entry_Array_Length( uint32_t_Hashmap_Entry_Array* a); uint32_t_Hashmap_Entry * uint32_t_Hashmap_Entry_Array_Begin( uint32_t_Hashmap_Entry_Array* a); uint32_t_Hashmap_Entry * uint32_t_Hashmap_Entry_Array_End( uint32_t_Hashmap_Entry_Array* a); uint32_t_Hashmap_Entry uint32_t_Hashmap_Entry_Array_Front( uint32_t_Hashmap_Entry_Array* a); uint32_t_Hashmap_Entry uint32_t_Hashmap_Entry_Array_Back( uint32_t_Hashmap_Entry_Array* a); void uint32_t_Hashmap_Entry_Array_Clear( uint32_t_Hashmap_Entry_Array* a); void uint32_t_Hashmap_Entry_Array_ShrinkToFit( uint32_t_Hashmap_Entry_Array* a); void uint32_t_Hashmap_Entry_Array_Resize( uint32_t_Hashmap_Entry_Array* a, size_t length); void uint32_t_Hashmap_Entry_Array_SetCapacity( uint32_t_Hashmap_Entry_Array* a, size_t capacity ); void uint32_t_Hashmap_Entry_Array_Reserve( uint32_t_Hashmap_Entry_Array* a, size_t capacity); void uint32_t_Hashmap_Entry_Array_Grow( uint32_t_Hashmap_Entry_Array* a, size_t minCapacity); inline uint32_t_Hashmap_Entry_Array uint32_t_Hashmap_Entry_Array_Create(void) { uint32_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint32_t_Hashmap_Entry_Array_Free( uint32_t_Hashmap_Entry_Array* a ) { free(a->data); } inline uint32_t_Hashmap_Entry uint32_t_Hashmap_Entry_Array_Get( uint32_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline uint32_t_Hashmap_Entry* uint32_t_Hashmap_Entry_Array_GetPtr( uint32_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void uint32_t_Hashmap_Entry_Array_Set( uint32_t_Hashmap_Entry_Array* a, size_t index, uint32_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t uint32_t_Hashmap_Entry_Array_Append( uint32_t_Hashmap_Entry_Array* a, uint32_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) uint32_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint32_t_Hashmap_Entry_Array_AppendMany( uint32_t_Hashmap_Entry_Array* a, uint32_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) uint32_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint32_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void uint32_t_Hashmap_Entry_Array_PopBack( uint32_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint32_t_Hashmap_Entry_Array_Length( uint32_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t uint32_t_Hashmap_Entry_Array_Capacity(uint32_t_Hashmap_Entry_Array* a) { return a->capacity; } inline uint32_t_Hashmap_Entry * uint32_t_Hashmap_Entry_Array_Begin(uint32_t_Hashmap_Entry_Array* a) { return a->data; } inline uint32_t_Hashmap_Entry * uint32_t_Hashmap_Entry_Array_End(uint32_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline uint32_t_Hashmap_Entry uint32_t_Hashmap_Entry_Array_Front(uint32_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint32_t_Hashmap_Entry_Array_Begin(a) ); } inline uint32_t_Hashmap_Entry uint32_t_Hashmap_Entry_Array_Back(uint32_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint32_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void uint32_t_Hashmap_Entry_Array_Clear(uint32_t_Hashmap_Entry_Array* a) { uint32_t_Hashmap_Entry_Array_Resize(a, 0); } inline void uint32_t_Hashmap_Entry_Array_ShrinkToFit(uint32_t_Hashmap_Entry_Array* a) { uint32_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void uint32_t_Hashmap_Entry_Array_Resize(uint32_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) uint32_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void uint32_t_Hashmap_Entry_Array_SetCapacity( uint32_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint32_t_Hashmap_Entry_Array_Resize(a, capacity); uint32_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( uint32_t_Hashmap_Entry * ) malloc( capacity * sizeof( uint32_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( uint32_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint32_t_Hashmap_Entry_Array_Reserve( uint32_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) uint32_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void uint32_t_Hashmap_Entry_Array_Grow( uint32_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint32_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; uint32_t_Hashmap_Entry_Array data; } uint32_t_Hashmap; uint32_t_Hashmap uint32_t_Hashmap_Create(void); void uint32_t_Hashmap_Free( uint32_t_Hashmap* h); size_t uint32_t_Hashmap_Impl_AddEntry( uint32_t_Hashmap* h, uint64_t key); void uint32_t_Hashmap_Impl_Erase( uint32_t_Hashmap* h, FindResult* fr); FindResult uint32_t_Hashmap_Impl_FindByKey( uint32_t_Hashmap* h, uint64_t key); FindResult uint32_t_Hashmap_Impl_FindByEntry( uint32_t_Hashmap* h, uint32_t_Hashmap_Entry* e); size_t uint32_t_Hashmap_Impl_Make( uint32_t_Hashmap* h, uint64_t key); void uint32_t_Hashmap_Impl_FindAndErase(uint32_t_Hashmap* h, uint64_t key); size_t uint32_t_Hashmap_Impl_FindOrFail(uint32_t_Hashmap* h, uint64_t key); size_t uint32_t_Hashmap_Impl_FindOrMake( uint32_t_Hashmap* h, uint64_t key); void uint32_t_Hashmap_Impl_Rehash( uint32_t_Hashmap* h, size_t newCapacity); void uint32_t_Hashmap_Impl_Grow( uint32_t_Hashmap* h); char uint32_t_Hashmap_Impl_Full( uint32_t_Hashmap* h); char uint32_t_Hashmap_Has( uint32_t_Hashmap* h, uint64_t key); uint32_t uint32_t_Hashmap_Get( uint32_t_Hashmap* h, uint64_t key, uint32_t defaultValue ); uint32_t * uint32_t_Hashmap_GetPtr( uint32_t_Hashmap* h, uint64_t key, uint32_t * defaultValue ); size_t uint32_t_Hashmap_Set( uint32_t_Hashmap* h, uint64_t key, uint32_t value ); size_t uint32_t_Hashmap_SetPtr( uint32_t_Hashmap* h, uint64_t key, uint32_t* value ); void uint32_t_Hashmap_Remove( uint32_t_Hashmap* h, uint64_t key ); void uint32_t_Hashmap_Reserve( uint32_t_Hashmap* h, size_t capacity ); void uint32_t_Hashmap_Clear( uint32_t_Hashmap* h ); void uint32_t_Hashmap_Multi_Get( uint32_t_Hashmap* h, uint64_t key, uint32_t_Array * items ); void uint32_t_Hashmap_Multi_GetPtrs( uint32_t_Hashmap* h, uint64_t key, Containment_Ptr_uint32_t_Array * items ); size_t uint32_t_Hashmap_Multi_Count( uint32_t_Hashmap* h, uint64_t key ); void uint32_t_Hashmap_Multi_Insert( uint32_t_Hashmap* h, uint64_t key, uint32_t value ); void uint32_t_Hashmap_Multi_InsertMany( uint32_t_Hashmap* h, uint64_t key, uint32_t * values, size_t count ); uint32_t_Hashmap_Entry* uint32_t_Hashmap_Multi_FindFirst( uint32_t_Hashmap* h, uint64_t key); uint32_t_Hashmap_Entry* uint32_t_Hashmap_Multi_FindNext( uint32_t_Hashmap* h, uint32_t_Hashmap_Entry* e); void uint32_t_Hashmap_Multi_Remove( uint32_t_Hashmap* h, uint32_t_Hashmap_Entry* e); void uint32_t_Hashmap_Multi_RemoveAll(uint32_t_Hashmap* h, uint64_t key); inline uint32_t_Hashmap uint32_t_Hashmap_Create(void) { uint32_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = uint32_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void uint32_t_Hashmap_Free( uint32_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); uint32_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t uint32_t_Hashmap_Impl_AddEntry( uint32_t_Hashmap* h, uint64_t key) { uint32_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; uint32_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void uint32_t_Hashmap_Impl_Erase( uint32_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; uint32_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = uint32_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult uint32_t_Hashmap_Impl_FindByKey( uint32_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult uint32_t_Hashmap_Impl_FindByEntry( uint32_t_Hashmap* h, uint32_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t uint32_t_Hashmap_Impl_Make( uint32_t_Hashmap* h, uint64_t key) { FindResult fr = uint32_t_Hashmap_Impl_FindByKey(h, key); size_t index = uint32_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void uint32_t_Hashmap_Impl_FindAndErase( uint32_t_Hashmap* h, uint64_t key) { FindResult fr = uint32_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) uint32_t_Hashmap_Impl_Erase(h, &fr); } inline size_t uint32_t_Hashmap_Impl_FindOrFail( uint32_t_Hashmap* h, uint64_t key) { return uint32_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t uint32_t_Hashmap_Impl_FindOrMake( uint32_t_Hashmap* h, uint64_t key) { FindResult fr = uint32_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = uint32_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void uint32_t_Hashmap_Impl_Rehash( uint32_t_Hashmap* h, size_t newCapacity) { uint32_t_Hashmap nh = uint32_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; uint32_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { uint32_t_Hashmap_Entry* e = &h->data.data[i]; uint32_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = uint32_t_Hashmap_Create(); } inline void uint32_t_Hashmap_Impl_Grow( uint32_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; uint32_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char uint32_t_Hashmap_Impl_Full( uint32_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char uint32_t_Hashmap_Has( uint32_t_Hashmap* h, uint64_t key) { return uint32_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline uint32_t uint32_t_Hashmap_Get( uint32_t_Hashmap* h, uint64_t key, uint32_t defaultValue ) { size_t index = uint32_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline uint32_t * uint32_t_Hashmap_GetPtr( uint32_t_Hashmap* h, uint64_t key, uint32_t * defaultValue ) { size_t index = uint32_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t uint32_t_Hashmap_Set( uint32_t_Hashmap* h, uint64_t key, uint32_t value ) { if (h->hashes.length == 0) uint32_t_Hashmap_Impl_Grow(h); size_t index = uint32_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (uint32_t_Hashmap_Impl_Full(h)) uint32_t_Hashmap_Impl_Grow(h); return index; } inline size_t uint32_t_Hashmap_SetPtr( uint32_t_Hashmap* h, uint64_t key, uint32_t* value ) { if (h->hashes.length == 0) uint32_t_Hashmap_Impl_Grow(h); size_t index = uint32_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (uint32_t_Hashmap_Impl_Full(h)) uint32_t_Hashmap_Impl_Grow(h); return index; } inline void uint32_t_Hashmap_Remove( uint32_t_Hashmap* h, uint64_t key ) { uint32_t_Hashmap_Impl_FindAndErase(h, key); } inline void uint32_t_Hashmap_Reserve( uint32_t_Hashmap* h, size_t capacity ) { uint32_t_Hashmap_Impl_Rehash(h, capacity); } inline void uint32_t_Hashmap_Clear( uint32_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); uint32_t_Hashmap_Entry_Array_Clear(&h->data); } inline void uint32_t_Hashmap_Multi_Get( uint32_t_Hashmap* h, uint64_t key, uint32_t_Array * items ) { uint32_t_Hashmap_Entry* e = uint32_t_Hashmap_Multi_FindFirst(h, key); while (e) { uint32_t_Array_Append(items, e->value); e = uint32_t_Hashmap_Multi_FindNext(h, e); } } inline void uint32_t_Hashmap_Multi_GetPtrs( uint32_t_Hashmap* h, uint64_t key, Containment_Ptr_uint32_t_Array * items ) { uint32_t_Hashmap_Entry* e = uint32_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_uint32_t_Array_Append(items, & (e->value) ); e = uint32_t_Hashmap_Multi_FindNext(h, e); } } inline size_t uint32_t_Hashmap_Multi_Count( uint32_t_Hashmap* h, uint64_t key ) { uint32_t_Hashmap_Entry* e = uint32_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = uint32_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void uint32_t_Hashmap_Multi_Insert( uint32_t_Hashmap* h, uint64_t key, uint32_t value ) { if (h->hashes.length == 0) uint32_t_Hashmap_Impl_Grow(h); size_t next = uint32_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (uint32_t_Hashmap_Impl_Full(h)) uint32_t_Hashmap_Impl_Grow(h); } inline void uint32_t_Hashmap_Multi_InsertMany( uint32_t_Hashmap* h, uint64_t key, uint32_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { uint32_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline uint32_t_Hashmap_Entry* uint32_t_Hashmap_Multi_FindFirst( uint32_t_Hashmap* h, uint64_t key) { size_t index = uint32_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline uint32_t_Hashmap_Entry* uint32_t_Hashmap_Multi_FindNext( uint32_t_Hashmap* h, uint32_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void uint32_t_Hashmap_Multi_Remove( uint32_t_Hashmap* h, uint32_t_Hashmap_Entry* e) { FindResult fr = uint32_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) uint32_t_Hashmap_Impl_Erase(h, &fr); } inline void uint32_t_Hashmap_Multi_RemoveAll(uint32_t_Hashmap* h, uint64_t key) { while (uint32_t_Hashmap_Has(h, key)) uint32_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; int64_t * data; } int64_t_Array ; int64_t_Array int64_t_Array_Create(void); void int64_t_Array_Free( int64_t_Array* a ); int64_t int64_t_Array_Get( int64_t_Array* a, size_t index); int64_t* int64_t_Array_GetPtr( int64_t_Array* a, size_t index); void int64_t_Array_Set( int64_t_Array* a, size_t index, int64_t value ); size_t int64_t_Array_Append( int64_t_Array* a, int64_t item); size_t int64_t_Array_AppendMany( int64_t_Array* a, int64_t * items, size_t count); void int64_t_Array_PopBack( int64_t_Array* a); size_t int64_t_Array_Length( int64_t_Array* a); int64_t * int64_t_Array_Begin( int64_t_Array* a); int64_t * int64_t_Array_End( int64_t_Array* a); int64_t int64_t_Array_Front( int64_t_Array* a); int64_t int64_t_Array_Back( int64_t_Array* a); void int64_t_Array_Clear( int64_t_Array* a); void int64_t_Array_ShrinkToFit( int64_t_Array* a); void int64_t_Array_Resize( int64_t_Array* a, size_t length); void int64_t_Array_SetCapacity( int64_t_Array* a, size_t capacity ); void int64_t_Array_Reserve( int64_t_Array* a, size_t capacity); void int64_t_Array_Grow( int64_t_Array* a, size_t minCapacity); inline int64_t_Array int64_t_Array_Create(void) { int64_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int64_t_Array_Free( int64_t_Array* a ) { free(a->data); } inline int64_t int64_t_Array_Get( int64_t_Array* a, size_t index) { return a->data[index]; } inline int64_t* int64_t_Array_GetPtr( int64_t_Array* a, size_t index) { return & (a->data[index]); } inline void int64_t_Array_Set( int64_t_Array* a, size_t index, int64_t value ) { a->data[index] = value; } inline size_t int64_t_Array_Append( int64_t_Array* a, int64_t item) { if (a->length + 1 > a->capacity) int64_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int64_t_Array_AppendMany( int64_t_Array* a, int64_t * items, size_t count) { if (a->capacity <= a->length + count) int64_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int64_t ) ); a->length += count; return a->length; }inline void int64_t_Array_PopBack( int64_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t int64_t_Array_Length( int64_t_Array* a) { return a->length; } inline size_t int64_t_Array_Capacity(int64_t_Array* a) { return a->capacity; } inline int64_t * int64_t_Array_Begin(int64_t_Array* a) { return a->data; } inline int64_t * int64_t_Array_End(int64_t_Array* a) { return a->data + a->length; } inline int64_t int64_t_Array_Front(int64_t_Array* a) { assert(a->length > 0); return * ( int64_t_Array_Begin(a) ); } inline int64_t int64_t_Array_Back(int64_t_Array* a) { assert(a->length > 0); return * ( int64_t_Array_End(a) - 1 ); } inline void int64_t_Array_Clear(int64_t_Array* a) { int64_t_Array_Resize(a, 0); } inline void int64_t_Array_ShrinkToFit(int64_t_Array* a) { int64_t_Array_SetCapacity(a, a->length); } inline void int64_t_Array_Resize(int64_t_Array* a, size_t length) { if (length > a->capacity) int64_t_Array_Grow(a, length); a->length = length; } inline void int64_t_Array_SetCapacity( int64_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int64_t_Array_Resize(a, capacity); int64_t * data = NULL; if (capacity > 0) { data = ( int64_t * ) malloc( capacity * sizeof( int64_t ) ); memcpy(data, a->data, a->length * sizeof( int64_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int64_t_Array_Reserve( int64_t_Array* a, size_t capacity) { if (capacity > a->capacity) int64_t_Array_SetCapacity(a, capacity); } inline void int64_t_Array_Grow( int64_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int64_t_Array_SetCapacity(a, capacity); } typedef int64_t *Containment_Ptr_int64_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_int64_t * data; } Containment_Ptr_int64_t_Array ; Containment_Ptr_int64_t_Array Containment_Ptr_int64_t_Array_Create(void); void Containment_Ptr_int64_t_Array_Free( Containment_Ptr_int64_t_Array* a ); Containment_Ptr_int64_t Containment_Ptr_int64_t_Array_Get( Containment_Ptr_int64_t_Array* a, size_t index); Containment_Ptr_int64_t* Containment_Ptr_int64_t_Array_GetPtr( Containment_Ptr_int64_t_Array* a, size_t index); void Containment_Ptr_int64_t_Array_Set( Containment_Ptr_int64_t_Array* a, size_t index, Containment_Ptr_int64_t value ); size_t Containment_Ptr_int64_t_Array_Append( Containment_Ptr_int64_t_Array* a, Containment_Ptr_int64_t item); size_t Containment_Ptr_int64_t_Array_AppendMany( Containment_Ptr_int64_t_Array* a, Containment_Ptr_int64_t * items, size_t count); void Containment_Ptr_int64_t_Array_PopBack( Containment_Ptr_int64_t_Array* a); size_t Containment_Ptr_int64_t_Array_Length( Containment_Ptr_int64_t_Array* a); Containment_Ptr_int64_t * Containment_Ptr_int64_t_Array_Begin( Containment_Ptr_int64_t_Array* a); Containment_Ptr_int64_t * Containment_Ptr_int64_t_Array_End( Containment_Ptr_int64_t_Array* a); Containment_Ptr_int64_t Containment_Ptr_int64_t_Array_Front( Containment_Ptr_int64_t_Array* a); Containment_Ptr_int64_t Containment_Ptr_int64_t_Array_Back( Containment_Ptr_int64_t_Array* a); void Containment_Ptr_int64_t_Array_Clear( Containment_Ptr_int64_t_Array* a); void Containment_Ptr_int64_t_Array_ShrinkToFit( Containment_Ptr_int64_t_Array* a); void Containment_Ptr_int64_t_Array_Resize( Containment_Ptr_int64_t_Array* a, size_t length); void Containment_Ptr_int64_t_Array_SetCapacity( Containment_Ptr_int64_t_Array* a, size_t capacity ); void Containment_Ptr_int64_t_Array_Reserve( Containment_Ptr_int64_t_Array* a, size_t capacity); void Containment_Ptr_int64_t_Array_Grow( Containment_Ptr_int64_t_Array* a, size_t minCapacity); inline Containment_Ptr_int64_t_Array Containment_Ptr_int64_t_Array_Create(void) { Containment_Ptr_int64_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_int64_t_Array_Free( Containment_Ptr_int64_t_Array* a ) { free(a->data); } inline Containment_Ptr_int64_t Containment_Ptr_int64_t_Array_Get( Containment_Ptr_int64_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_int64_t* Containment_Ptr_int64_t_Array_GetPtr( Containment_Ptr_int64_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_int64_t_Array_Set( Containment_Ptr_int64_t_Array* a, size_t index, Containment_Ptr_int64_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_int64_t_Array_Append( Containment_Ptr_int64_t_Array* a, Containment_Ptr_int64_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_int64_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_int64_t_Array_AppendMany( Containment_Ptr_int64_t_Array* a, Containment_Ptr_int64_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_int64_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_int64_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_int64_t_Array_PopBack( Containment_Ptr_int64_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_int64_t_Array_Length( Containment_Ptr_int64_t_Array* a) { return a->length; } inline size_t Containment_Ptr_int64_t_Array_Capacity(Containment_Ptr_int64_t_Array* a) { return a->capacity; } inline Containment_Ptr_int64_t * Containment_Ptr_int64_t_Array_Begin(Containment_Ptr_int64_t_Array* a) { return a->data; } inline Containment_Ptr_int64_t * Containment_Ptr_int64_t_Array_End(Containment_Ptr_int64_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_int64_t Containment_Ptr_int64_t_Array_Front(Containment_Ptr_int64_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int64_t_Array_Begin(a) ); } inline Containment_Ptr_int64_t Containment_Ptr_int64_t_Array_Back(Containment_Ptr_int64_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_int64_t_Array_End(a) - 1 ); } inline void Containment_Ptr_int64_t_Array_Clear(Containment_Ptr_int64_t_Array* a) { Containment_Ptr_int64_t_Array_Resize(a, 0); } inline void Containment_Ptr_int64_t_Array_ShrinkToFit(Containment_Ptr_int64_t_Array* a) { Containment_Ptr_int64_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_int64_t_Array_Resize(Containment_Ptr_int64_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_int64_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_int64_t_Array_SetCapacity( Containment_Ptr_int64_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_int64_t_Array_Resize(a, capacity); Containment_Ptr_int64_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_int64_t * ) malloc( capacity * sizeof( Containment_Ptr_int64_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_int64_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_int64_t_Array_Reserve( Containment_Ptr_int64_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_int64_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_int64_t_Array_Grow( Containment_Ptr_int64_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_int64_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; int64_t value; } int64_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; int64_t_Hashmap_Entry * data; } int64_t_Hashmap_Entry_Array ; int64_t_Hashmap_Entry_Array int64_t_Hashmap_Entry_Array_Create(void); void int64_t_Hashmap_Entry_Array_Free( int64_t_Hashmap_Entry_Array* a ); int64_t_Hashmap_Entry int64_t_Hashmap_Entry_Array_Get( int64_t_Hashmap_Entry_Array* a, size_t index); int64_t_Hashmap_Entry* int64_t_Hashmap_Entry_Array_GetPtr( int64_t_Hashmap_Entry_Array* a, size_t index); void int64_t_Hashmap_Entry_Array_Set( int64_t_Hashmap_Entry_Array* a, size_t index, int64_t_Hashmap_Entry value ); size_t int64_t_Hashmap_Entry_Array_Append( int64_t_Hashmap_Entry_Array* a, int64_t_Hashmap_Entry item); size_t int64_t_Hashmap_Entry_Array_AppendMany( int64_t_Hashmap_Entry_Array* a, int64_t_Hashmap_Entry * items, size_t count); void int64_t_Hashmap_Entry_Array_PopBack( int64_t_Hashmap_Entry_Array* a); size_t int64_t_Hashmap_Entry_Array_Length( int64_t_Hashmap_Entry_Array* a); int64_t_Hashmap_Entry * int64_t_Hashmap_Entry_Array_Begin( int64_t_Hashmap_Entry_Array* a); int64_t_Hashmap_Entry * int64_t_Hashmap_Entry_Array_End( int64_t_Hashmap_Entry_Array* a); int64_t_Hashmap_Entry int64_t_Hashmap_Entry_Array_Front( int64_t_Hashmap_Entry_Array* a); int64_t_Hashmap_Entry int64_t_Hashmap_Entry_Array_Back( int64_t_Hashmap_Entry_Array* a); void int64_t_Hashmap_Entry_Array_Clear( int64_t_Hashmap_Entry_Array* a); void int64_t_Hashmap_Entry_Array_ShrinkToFit( int64_t_Hashmap_Entry_Array* a); void int64_t_Hashmap_Entry_Array_Resize( int64_t_Hashmap_Entry_Array* a, size_t length); void int64_t_Hashmap_Entry_Array_SetCapacity( int64_t_Hashmap_Entry_Array* a, size_t capacity ); void int64_t_Hashmap_Entry_Array_Reserve( int64_t_Hashmap_Entry_Array* a, size_t capacity); void int64_t_Hashmap_Entry_Array_Grow( int64_t_Hashmap_Entry_Array* a, size_t minCapacity); inline int64_t_Hashmap_Entry_Array int64_t_Hashmap_Entry_Array_Create(void) { int64_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void int64_t_Hashmap_Entry_Array_Free( int64_t_Hashmap_Entry_Array* a ) { free(a->data); } inline int64_t_Hashmap_Entry int64_t_Hashmap_Entry_Array_Get( int64_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline int64_t_Hashmap_Entry* int64_t_Hashmap_Entry_Array_GetPtr( int64_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void int64_t_Hashmap_Entry_Array_Set( int64_t_Hashmap_Entry_Array* a, size_t index, int64_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t int64_t_Hashmap_Entry_Array_Append( int64_t_Hashmap_Entry_Array* a, int64_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) int64_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t int64_t_Hashmap_Entry_Array_AppendMany( int64_t_Hashmap_Entry_Array* a, int64_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) int64_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( int64_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void int64_t_Hashmap_Entry_Array_PopBack( int64_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t int64_t_Hashmap_Entry_Array_Length( int64_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t int64_t_Hashmap_Entry_Array_Capacity(int64_t_Hashmap_Entry_Array* a) { return a->capacity; } inline int64_t_Hashmap_Entry * int64_t_Hashmap_Entry_Array_Begin(int64_t_Hashmap_Entry_Array* a) { return a->data; } inline int64_t_Hashmap_Entry * int64_t_Hashmap_Entry_Array_End(int64_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline int64_t_Hashmap_Entry int64_t_Hashmap_Entry_Array_Front(int64_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int64_t_Hashmap_Entry_Array_Begin(a) ); } inline int64_t_Hashmap_Entry int64_t_Hashmap_Entry_Array_Back(int64_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( int64_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void int64_t_Hashmap_Entry_Array_Clear(int64_t_Hashmap_Entry_Array* a) { int64_t_Hashmap_Entry_Array_Resize(a, 0); } inline void int64_t_Hashmap_Entry_Array_ShrinkToFit(int64_t_Hashmap_Entry_Array* a) { int64_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void int64_t_Hashmap_Entry_Array_Resize(int64_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) int64_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void int64_t_Hashmap_Entry_Array_SetCapacity( int64_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) int64_t_Hashmap_Entry_Array_Resize(a, capacity); int64_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( int64_t_Hashmap_Entry * ) malloc( capacity * sizeof( int64_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( int64_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void int64_t_Hashmap_Entry_Array_Reserve( int64_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) int64_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void int64_t_Hashmap_Entry_Array_Grow( int64_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; int64_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; int64_t_Hashmap_Entry_Array data; } int64_t_Hashmap; int64_t_Hashmap int64_t_Hashmap_Create(void); void int64_t_Hashmap_Free( int64_t_Hashmap* h); size_t int64_t_Hashmap_Impl_AddEntry( int64_t_Hashmap* h, uint64_t key); void int64_t_Hashmap_Impl_Erase( int64_t_Hashmap* h, FindResult* fr); FindResult int64_t_Hashmap_Impl_FindByKey( int64_t_Hashmap* h, uint64_t key); FindResult int64_t_Hashmap_Impl_FindByEntry( int64_t_Hashmap* h, int64_t_Hashmap_Entry* e); size_t int64_t_Hashmap_Impl_Make( int64_t_Hashmap* h, uint64_t key); void int64_t_Hashmap_Impl_FindAndErase(int64_t_Hashmap* h, uint64_t key); size_t int64_t_Hashmap_Impl_FindOrFail(int64_t_Hashmap* h, uint64_t key); size_t int64_t_Hashmap_Impl_FindOrMake( int64_t_Hashmap* h, uint64_t key); void int64_t_Hashmap_Impl_Rehash( int64_t_Hashmap* h, size_t newCapacity); void int64_t_Hashmap_Impl_Grow( int64_t_Hashmap* h); char int64_t_Hashmap_Impl_Full( int64_t_Hashmap* h); char int64_t_Hashmap_Has( int64_t_Hashmap* h, uint64_t key); int64_t int64_t_Hashmap_Get( int64_t_Hashmap* h, uint64_t key, int64_t defaultValue ); int64_t * int64_t_Hashmap_GetPtr( int64_t_Hashmap* h, uint64_t key, int64_t * defaultValue ); size_t int64_t_Hashmap_Set( int64_t_Hashmap* h, uint64_t key, int64_t value ); size_t int64_t_Hashmap_SetPtr( int64_t_Hashmap* h, uint64_t key, int64_t* value ); void int64_t_Hashmap_Remove( int64_t_Hashmap* h, uint64_t key ); void int64_t_Hashmap_Reserve( int64_t_Hashmap* h, size_t capacity ); void int64_t_Hashmap_Clear( int64_t_Hashmap* h ); void int64_t_Hashmap_Multi_Get( int64_t_Hashmap* h, uint64_t key, int64_t_Array * items ); void int64_t_Hashmap_Multi_GetPtrs( int64_t_Hashmap* h, uint64_t key, Containment_Ptr_int64_t_Array * items ); size_t int64_t_Hashmap_Multi_Count( int64_t_Hashmap* h, uint64_t key ); void int64_t_Hashmap_Multi_Insert( int64_t_Hashmap* h, uint64_t key, int64_t value ); void int64_t_Hashmap_Multi_InsertMany( int64_t_Hashmap* h, uint64_t key, int64_t * values, size_t count ); int64_t_Hashmap_Entry* int64_t_Hashmap_Multi_FindFirst( int64_t_Hashmap* h, uint64_t key); int64_t_Hashmap_Entry* int64_t_Hashmap_Multi_FindNext( int64_t_Hashmap* h, int64_t_Hashmap_Entry* e); void int64_t_Hashmap_Multi_Remove( int64_t_Hashmap* h, int64_t_Hashmap_Entry* e); void int64_t_Hashmap_Multi_RemoveAll(int64_t_Hashmap* h, uint64_t key); inline int64_t_Hashmap int64_t_Hashmap_Create(void) { int64_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = int64_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void int64_t_Hashmap_Free( int64_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); int64_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t int64_t_Hashmap_Impl_AddEntry( int64_t_Hashmap* h, uint64_t key) { int64_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; int64_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void int64_t_Hashmap_Impl_Erase( int64_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; int64_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = int64_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult int64_t_Hashmap_Impl_FindByKey( int64_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult int64_t_Hashmap_Impl_FindByEntry( int64_t_Hashmap* h, int64_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t int64_t_Hashmap_Impl_Make( int64_t_Hashmap* h, uint64_t key) { FindResult fr = int64_t_Hashmap_Impl_FindByKey(h, key); size_t index = int64_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void int64_t_Hashmap_Impl_FindAndErase( int64_t_Hashmap* h, uint64_t key) { FindResult fr = int64_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) int64_t_Hashmap_Impl_Erase(h, &fr); } inline size_t int64_t_Hashmap_Impl_FindOrFail( int64_t_Hashmap* h, uint64_t key) { return int64_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t int64_t_Hashmap_Impl_FindOrMake( int64_t_Hashmap* h, uint64_t key) { FindResult fr = int64_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = int64_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void int64_t_Hashmap_Impl_Rehash( int64_t_Hashmap* h, size_t newCapacity) { int64_t_Hashmap nh = int64_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; int64_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { int64_t_Hashmap_Entry* e = &h->data.data[i]; int64_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = int64_t_Hashmap_Create(); } inline void int64_t_Hashmap_Impl_Grow( int64_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; int64_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char int64_t_Hashmap_Impl_Full( int64_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char int64_t_Hashmap_Has( int64_t_Hashmap* h, uint64_t key) { return int64_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline int64_t int64_t_Hashmap_Get( int64_t_Hashmap* h, uint64_t key, int64_t defaultValue ) { size_t index = int64_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline int64_t * int64_t_Hashmap_GetPtr( int64_t_Hashmap* h, uint64_t key, int64_t * defaultValue ) { size_t index = int64_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t int64_t_Hashmap_Set( int64_t_Hashmap* h, uint64_t key, int64_t value ) { if (h->hashes.length == 0) int64_t_Hashmap_Impl_Grow(h); size_t index = int64_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (int64_t_Hashmap_Impl_Full(h)) int64_t_Hashmap_Impl_Grow(h); return index; } inline size_t int64_t_Hashmap_SetPtr( int64_t_Hashmap* h, uint64_t key, int64_t* value ) { if (h->hashes.length == 0) int64_t_Hashmap_Impl_Grow(h); size_t index = int64_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (int64_t_Hashmap_Impl_Full(h)) int64_t_Hashmap_Impl_Grow(h); return index; } inline void int64_t_Hashmap_Remove( int64_t_Hashmap* h, uint64_t key ) { int64_t_Hashmap_Impl_FindAndErase(h, key); } inline void int64_t_Hashmap_Reserve( int64_t_Hashmap* h, size_t capacity ) { int64_t_Hashmap_Impl_Rehash(h, capacity); } inline void int64_t_Hashmap_Clear( int64_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); int64_t_Hashmap_Entry_Array_Clear(&h->data); } inline void int64_t_Hashmap_Multi_Get( int64_t_Hashmap* h, uint64_t key, int64_t_Array * items ) { int64_t_Hashmap_Entry* e = int64_t_Hashmap_Multi_FindFirst(h, key); while (e) { int64_t_Array_Append(items, e->value); e = int64_t_Hashmap_Multi_FindNext(h, e); } } inline void int64_t_Hashmap_Multi_GetPtrs( int64_t_Hashmap* h, uint64_t key, Containment_Ptr_int64_t_Array * items ) { int64_t_Hashmap_Entry* e = int64_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_int64_t_Array_Append(items, & (e->value) ); e = int64_t_Hashmap_Multi_FindNext(h, e); } } inline size_t int64_t_Hashmap_Multi_Count( int64_t_Hashmap* h, uint64_t key ) { int64_t_Hashmap_Entry* e = int64_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = int64_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void int64_t_Hashmap_Multi_Insert( int64_t_Hashmap* h, uint64_t key, int64_t value ) { if (h->hashes.length == 0) int64_t_Hashmap_Impl_Grow(h); size_t next = int64_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (int64_t_Hashmap_Impl_Full(h)) int64_t_Hashmap_Impl_Grow(h); } inline void int64_t_Hashmap_Multi_InsertMany( int64_t_Hashmap* h, uint64_t key, int64_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { int64_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline int64_t_Hashmap_Entry* int64_t_Hashmap_Multi_FindFirst( int64_t_Hashmap* h, uint64_t key) { size_t index = int64_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline int64_t_Hashmap_Entry* int64_t_Hashmap_Multi_FindNext( int64_t_Hashmap* h, int64_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void int64_t_Hashmap_Multi_Remove( int64_t_Hashmap* h, int64_t_Hashmap_Entry* e) { FindResult fr = int64_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) int64_t_Hashmap_Impl_Erase(h, &fr); } inline void int64_t_Hashmap_Multi_RemoveAll(int64_t_Hashmap* h, uint64_t key) { while (int64_t_Hashmap_Has(h, key)) int64_t_Hashmap_Remove(h, key); }
typedef struct { size_t length; size_t capacity; uint64_t * data; } uint64_t_Array ; uint64_t_Array uint64_t_Array_Create(void); void uint64_t_Array_Free( uint64_t_Array* a ); uint64_t uint64_t_Array_Get( uint64_t_Array* a, size_t index); uint64_t* uint64_t_Array_GetPtr( uint64_t_Array* a, size_t index); void uint64_t_Array_Set( uint64_t_Array* a, size_t index, uint64_t value ); size_t uint64_t_Array_Append( uint64_t_Array* a, uint64_t item); size_t uint64_t_Array_AppendMany( uint64_t_Array* a, uint64_t * items, size_t count); void uint64_t_Array_PopBack( uint64_t_Array* a); size_t uint64_t_Array_Length( uint64_t_Array* a); uint64_t * uint64_t_Array_Begin( uint64_t_Array* a); uint64_t * uint64_t_Array_End( uint64_t_Array* a); uint64_t uint64_t_Array_Front( uint64_t_Array* a); uint64_t uint64_t_Array_Back( uint64_t_Array* a); void uint64_t_Array_Clear( uint64_t_Array* a); void uint64_t_Array_ShrinkToFit( uint64_t_Array* a); void uint64_t_Array_Resize( uint64_t_Array* a, size_t length); void uint64_t_Array_SetCapacity( uint64_t_Array* a, size_t capacity ); void uint64_t_Array_Reserve( uint64_t_Array* a, size_t capacity); void uint64_t_Array_Grow( uint64_t_Array* a, size_t minCapacity); inline uint64_t_Array uint64_t_Array_Create(void) { uint64_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint64_t_Array_Free( uint64_t_Array* a ) { free(a->data); } inline uint64_t uint64_t_Array_Get( uint64_t_Array* a, size_t index) { return a->data[index]; } inline uint64_t* uint64_t_Array_GetPtr( uint64_t_Array* a, size_t index) { return & (a->data[index]); } inline void uint64_t_Array_Set( uint64_t_Array* a, size_t index, uint64_t value ) { a->data[index] = value; } inline size_t uint64_t_Array_Append( uint64_t_Array* a, uint64_t item) { if (a->length + 1 > a->capacity) uint64_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint64_t_Array_AppendMany( uint64_t_Array* a, uint64_t * items, size_t count) { if (a->capacity <= a->length + count) uint64_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint64_t ) ); a->length += count; return a->length; }inline void uint64_t_Array_PopBack( uint64_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint64_t_Array_Length( uint64_t_Array* a) { return a->length; } inline size_t uint64_t_Array_Capacity(uint64_t_Array* a) { return a->capacity; } inline uint64_t * uint64_t_Array_Begin(uint64_t_Array* a) { return a->data; } inline uint64_t * uint64_t_Array_End(uint64_t_Array* a) { return a->data + a->length; } inline uint64_t uint64_t_Array_Front(uint64_t_Array* a) { assert(a->length > 0); return * ( uint64_t_Array_Begin(a) ); } inline uint64_t uint64_t_Array_Back(uint64_t_Array* a) { assert(a->length > 0); return * ( uint64_t_Array_End(a) - 1 ); } inline void uint64_t_Array_Clear(uint64_t_Array* a) { uint64_t_Array_Resize(a, 0); } inline void uint64_t_Array_ShrinkToFit(uint64_t_Array* a) { uint64_t_Array_SetCapacity(a, a->length); } inline void uint64_t_Array_Resize(uint64_t_Array* a, size_t length) { if (length > a->capacity) uint64_t_Array_Grow(a, length); a->length = length; } inline void uint64_t_Array_SetCapacity( uint64_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint64_t_Array_Resize(a, capacity); uint64_t * data = NULL; if (capacity > 0) { data = ( uint64_t * ) malloc( capacity * sizeof( uint64_t ) ); memcpy(data, a->data, a->length * sizeof( uint64_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint64_t_Array_Reserve( uint64_t_Array* a, size_t capacity) { if (capacity > a->capacity) uint64_t_Array_SetCapacity(a, capacity); } inline void uint64_t_Array_Grow( uint64_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint64_t_Array_SetCapacity(a, capacity); } typedef uint64_t *Containment_Ptr_uint64_t ; typedef struct { size_t length; size_t capacity; Containment_Ptr_uint64_t * data; } Containment_Ptr_uint64_t_Array ; Containment_Ptr_uint64_t_Array Containment_Ptr_uint64_t_Array_Create(void); void Containment_Ptr_uint64_t_Array_Free( Containment_Ptr_uint64_t_Array* a ); Containment_Ptr_uint64_t Containment_Ptr_uint64_t_Array_Get( Containment_Ptr_uint64_t_Array* a, size_t index); Containment_Ptr_uint64_t* Containment_Ptr_uint64_t_Array_GetPtr( Containment_Ptr_uint64_t_Array* a, size_t index); void Containment_Ptr_uint64_t_Array_Set( Containment_Ptr_uint64_t_Array* a, size_t index, Containment_Ptr_uint64_t value ); size_t Containment_Ptr_uint64_t_Array_Append( Containment_Ptr_uint64_t_Array* a, Containment_Ptr_uint64_t item); size_t Containment_Ptr_uint64_t_Array_AppendMany( Containment_Ptr_uint64_t_Array* a, Containment_Ptr_uint64_t * items, size_t count); void Containment_Ptr_uint64_t_Array_PopBack( Containment_Ptr_uint64_t_Array* a); size_t Containment_Ptr_uint64_t_Array_Length( Containment_Ptr_uint64_t_Array* a); Containment_Ptr_uint64_t * Containment_Ptr_uint64_t_Array_Begin( Containment_Ptr_uint64_t_Array* a); Containment_Ptr_uint64_t * Containment_Ptr_uint64_t_Array_End( Containment_Ptr_uint64_t_Array* a); Containment_Ptr_uint64_t Containment_Ptr_uint64_t_Array_Front( Containment_Ptr_uint64_t_Array* a); Containment_Ptr_uint64_t Containment_Ptr_uint64_t_Array_Back( Containment_Ptr_uint64_t_Array* a); void Containment_Ptr_uint64_t_Array_Clear( Containment_Ptr_uint64_t_Array* a); void Containment_Ptr_uint64_t_Array_ShrinkToFit( Containment_Ptr_uint64_t_Array* a); void Containment_Ptr_uint64_t_Array_Resize( Containment_Ptr_uint64_t_Array* a, size_t length); void Containment_Ptr_uint64_t_Array_SetCapacity( Containment_Ptr_uint64_t_Array* a, size_t capacity ); void Containment_Ptr_uint64_t_Array_Reserve( Containment_Ptr_uint64_t_Array* a, size_t capacity); void Containment_Ptr_uint64_t_Array_Grow( Containment_Ptr_uint64_t_Array* a, size_t minCapacity); inline Containment_Ptr_uint64_t_Array Containment_Ptr_uint64_t_Array_Create(void) { Containment_Ptr_uint64_t_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void Containment_Ptr_uint64_t_Array_Free( Containment_Ptr_uint64_t_Array* a ) { free(a->data); } inline Containment_Ptr_uint64_t Containment_Ptr_uint64_t_Array_Get( Containment_Ptr_uint64_t_Array* a, size_t index) { return a->data[index]; } inline Containment_Ptr_uint64_t* Containment_Ptr_uint64_t_Array_GetPtr( Containment_Ptr_uint64_t_Array* a, size_t index) { return & (a->data[index]); } inline void Containment_Ptr_uint64_t_Array_Set( Containment_Ptr_uint64_t_Array* a, size_t index, Containment_Ptr_uint64_t value ) { a->data[index] = value; } inline size_t Containment_Ptr_uint64_t_Array_Append( Containment_Ptr_uint64_t_Array* a, Containment_Ptr_uint64_t item) { if (a->length + 1 > a->capacity) Containment_Ptr_uint64_t_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t Containment_Ptr_uint64_t_Array_AppendMany( Containment_Ptr_uint64_t_Array* a, Containment_Ptr_uint64_t * items, size_t count) { if (a->capacity <= a->length + count) Containment_Ptr_uint64_t_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( Containment_Ptr_uint64_t ) ); a->length += count; return a->length; }inline void Containment_Ptr_uint64_t_Array_PopBack( Containment_Ptr_uint64_t_Array* a) { assert(a->length > 0); a->length--; } inline size_t Containment_Ptr_uint64_t_Array_Length( Containment_Ptr_uint64_t_Array* a) { return a->length; } inline size_t Containment_Ptr_uint64_t_Array_Capacity(Containment_Ptr_uint64_t_Array* a) { return a->capacity; } inline Containment_Ptr_uint64_t * Containment_Ptr_uint64_t_Array_Begin(Containment_Ptr_uint64_t_Array* a) { return a->data; } inline Containment_Ptr_uint64_t * Containment_Ptr_uint64_t_Array_End(Containment_Ptr_uint64_t_Array* a) { return a->data + a->length; } inline Containment_Ptr_uint64_t Containment_Ptr_uint64_t_Array_Front(Containment_Ptr_uint64_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint64_t_Array_Begin(a) ); } inline Containment_Ptr_uint64_t Containment_Ptr_uint64_t_Array_Back(Containment_Ptr_uint64_t_Array* a) { assert(a->length > 0); return * ( Containment_Ptr_uint64_t_Array_End(a) - 1 ); } inline void Containment_Ptr_uint64_t_Array_Clear(Containment_Ptr_uint64_t_Array* a) { Containment_Ptr_uint64_t_Array_Resize(a, 0); } inline void Containment_Ptr_uint64_t_Array_ShrinkToFit(Containment_Ptr_uint64_t_Array* a) { Containment_Ptr_uint64_t_Array_SetCapacity(a, a->length); } inline void Containment_Ptr_uint64_t_Array_Resize(Containment_Ptr_uint64_t_Array* a, size_t length) { if (length > a->capacity) Containment_Ptr_uint64_t_Array_Grow(a, length); a->length = length; } inline void Containment_Ptr_uint64_t_Array_SetCapacity( Containment_Ptr_uint64_t_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) Containment_Ptr_uint64_t_Array_Resize(a, capacity); Containment_Ptr_uint64_t * data = NULL; if (capacity > 0) { data = ( Containment_Ptr_uint64_t * ) malloc( capacity * sizeof( Containment_Ptr_uint64_t ) ); memcpy(data, a->data, a->length * sizeof( Containment_Ptr_uint64_t ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void Containment_Ptr_uint64_t_Array_Reserve( Containment_Ptr_uint64_t_Array* a, size_t capacity) { if (capacity > a->capacity) Containment_Ptr_uint64_t_Array_SetCapacity(a, capacity); } inline void Containment_Ptr_uint64_t_Array_Grow( Containment_Ptr_uint64_t_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; Containment_Ptr_uint64_t_Array_SetCapacity(a, capacity); }; typedef struct { uint64_t key; size_t next; uint64_t value; } uint64_t_Hashmap_Entry; typedef struct { size_t length; size_t capacity; uint64_t_Hashmap_Entry * data; } uint64_t_Hashmap_Entry_Array ; uint64_t_Hashmap_Entry_Array uint64_t_Hashmap_Entry_Array_Create(void); void uint64_t_Hashmap_Entry_Array_Free( uint64_t_Hashmap_Entry_Array* a ); uint64_t_Hashmap_Entry uint64_t_Hashmap_Entry_Array_Get( uint64_t_Hashmap_Entry_Array* a, size_t index); uint64_t_Hashmap_Entry* uint64_t_Hashmap_Entry_Array_GetPtr( uint64_t_Hashmap_Entry_Array* a, size_t index); void uint64_t_Hashmap_Entry_Array_Set( uint64_t_Hashmap_Entry_Array* a, size_t index, uint64_t_Hashmap_Entry value ); size_t uint64_t_Hashmap_Entry_Array_Append( uint64_t_Hashmap_Entry_Array* a, uint64_t_Hashmap_Entry item); size_t uint64_t_Hashmap_Entry_Array_AppendMany( uint64_t_Hashmap_Entry_Array* a, uint64_t_Hashmap_Entry * items, size_t count); void uint64_t_Hashmap_Entry_Array_PopBack( uint64_t_Hashmap_Entry_Array* a); size_t uint64_t_Hashmap_Entry_Array_Length( uint64_t_Hashmap_Entry_Array* a); uint64_t_Hashmap_Entry * uint64_t_Hashmap_Entry_Array_Begin( uint64_t_Hashmap_Entry_Array* a); uint64_t_Hashmap_Entry * uint64_t_Hashmap_Entry_Array_End( uint64_t_Hashmap_Entry_Array* a); uint64_t_Hashmap_Entry uint64_t_Hashmap_Entry_Array_Front( uint64_t_Hashmap_Entry_Array* a); uint64_t_Hashmap_Entry uint64_t_Hashmap_Entry_Array_Back( uint64_t_Hashmap_Entry_Array* a); void uint64_t_Hashmap_Entry_Array_Clear( uint64_t_Hashmap_Entry_Array* a); void uint64_t_Hashmap_Entry_Array_ShrinkToFit( uint64_t_Hashmap_Entry_Array* a); void uint64_t_Hashmap_Entry_Array_Resize( uint64_t_Hashmap_Entry_Array* a, size_t length); void uint64_t_Hashmap_Entry_Array_SetCapacity( uint64_t_Hashmap_Entry_Array* a, size_t capacity ); void uint64_t_Hashmap_Entry_Array_Reserve( uint64_t_Hashmap_Entry_Array* a, size_t capacity); void uint64_t_Hashmap_Entry_Array_Grow( uint64_t_Hashmap_Entry_Array* a, size_t minCapacity); inline uint64_t_Hashmap_Entry_Array uint64_t_Hashmap_Entry_Array_Create(void) { uint64_t_Hashmap_Entry_Array a; a.length = 0; a.capacity = 0; a.data = NULL; return a; } inline void uint64_t_Hashmap_Entry_Array_Free( uint64_t_Hashmap_Entry_Array* a ) { free(a->data); } inline uint64_t_Hashmap_Entry uint64_t_Hashmap_Entry_Array_Get( uint64_t_Hashmap_Entry_Array* a, size_t index) { return a->data[index]; } inline uint64_t_Hashmap_Entry* uint64_t_Hashmap_Entry_Array_GetPtr( uint64_t_Hashmap_Entry_Array* a, size_t index) { return & (a->data[index]); } inline void uint64_t_Hashmap_Entry_Array_Set( uint64_t_Hashmap_Entry_Array* a, size_t index, uint64_t_Hashmap_Entry value ) { a->data[index] = value; } inline size_t uint64_t_Hashmap_Entry_Array_Append( uint64_t_Hashmap_Entry_Array* a, uint64_t_Hashmap_Entry item) { if (a->length + 1 > a->capacity) uint64_t_Hashmap_Entry_Array_Grow(a, a->length + 1); a->data[a->length++] = item; return a->length; }inline size_t uint64_t_Hashmap_Entry_Array_AppendMany( uint64_t_Hashmap_Entry_Array* a, uint64_t_Hashmap_Entry * items, size_t count) { if (a->capacity <= a->length + count) uint64_t_Hashmap_Entry_Array_Grow(a, a->length + count); memcpy(&a->data[a->length], items, count * sizeof( uint64_t_Hashmap_Entry ) ); a->length += count; return a->length; }inline void uint64_t_Hashmap_Entry_Array_PopBack( uint64_t_Hashmap_Entry_Array* a) { assert(a->length > 0); a->length--; } inline size_t uint64_t_Hashmap_Entry_Array_Length( uint64_t_Hashmap_Entry_Array* a) { return a->length; } inline size_t uint64_t_Hashmap_Entry_Array_Capacity(uint64_t_Hashmap_Entry_Array* a) { return a->capacity; } inline uint64_t_Hashmap_Entry * uint64_t_Hashmap_Entry_Array_Begin(uint64_t_Hashmap_Entry_Array* a) { return a->data; } inline uint64_t_Hashmap_Entry * uint64_t_Hashmap_Entry_Array_End(uint64_t_Hashmap_Entry_Array* a) { return a->data + a->length; } inline uint64_t_Hashmap_Entry uint64_t_Hashmap_Entry_Array_Front(uint64_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint64_t_Hashmap_Entry_Array_Begin(a) ); } inline uint64_t_Hashmap_Entry uint64_t_Hashmap_Entry_Array_Back(uint64_t_Hashmap_Entry_Array* a) { assert(a->length > 0); return * ( uint64_t_Hashmap_Entry_Array_End(a) - 1 ); } inline void uint64_t_Hashmap_Entry_Array_Clear(uint64_t_Hashmap_Entry_Array* a) { uint64_t_Hashmap_Entry_Array_Resize(a, 0); } inline void uint64_t_Hashmap_Entry_Array_ShrinkToFit(uint64_t_Hashmap_Entry_Array* a) { uint64_t_Hashmap_Entry_Array_SetCapacity(a, a->length); } inline void uint64_t_Hashmap_Entry_Array_Resize(uint64_t_Hashmap_Entry_Array* a, size_t length) { if (length > a->capacity) uint64_t_Hashmap_Entry_Array_Grow(a, length); a->length = length; } inline void uint64_t_Hashmap_Entry_Array_SetCapacity( uint64_t_Hashmap_Entry_Array* a, size_t capacity ) { if (capacity == a->capacity) return; if (capacity < a->capacity) uint64_t_Hashmap_Entry_Array_Resize(a, capacity); uint64_t_Hashmap_Entry * data = NULL; if (capacity > 0) { data = ( uint64_t_Hashmap_Entry * ) malloc( capacity * sizeof( uint64_t_Hashmap_Entry ) ); memcpy(data, a->data, a->length * sizeof( uint64_t_Hashmap_Entry ) ); } free( a->data ); a->data = data; a->capacity = capacity; } inline void uint64_t_Hashmap_Entry_Array_Reserve( uint64_t_Hashmap_Entry_Array* a, size_t capacity) { if (capacity > a->capacity) uint64_t_Hashmap_Entry_Array_SetCapacity(a, capacity); } inline void uint64_t_Hashmap_Entry_Array_Grow( uint64_t_Hashmap_Entry_Array* a, size_t minCapacity) { size_t capacity = 2 * a->capacity + 2; if (capacity < minCapacity) capacity = minCapacity; uint64_t_Hashmap_Entry_Array_SetCapacity(a, capacity); }; typedef struct { size_t_Array hashes; uint64_t_Hashmap_Entry_Array data; } uint64_t_Hashmap; uint64_t_Hashmap uint64_t_Hashmap_Create(void); void uint64_t_Hashmap_Free( uint64_t_Hashmap* h); size_t uint64_t_Hashmap_Impl_AddEntry( uint64_t_Hashmap* h, uint64_t key); void uint64_t_Hashmap_Impl_Erase( uint64_t_Hashmap* h, FindResult* fr); FindResult uint64_t_Hashmap_Impl_FindByKey( uint64_t_Hashmap* h, uint64_t key); FindResult uint64_t_Hashmap_Impl_FindByEntry( uint64_t_Hashmap* h, uint64_t_Hashmap_Entry* e); size_t uint64_t_Hashmap_Impl_Make( uint64_t_Hashmap* h, uint64_t key); void uint64_t_Hashmap_Impl_FindAndErase(uint64_t_Hashmap* h, uint64_t key); size_t uint64_t_Hashmap_Impl_FindOrFail(uint64_t_Hashmap* h, uint64_t key); size_t uint64_t_Hashmap_Impl_FindOrMake( uint64_t_Hashmap* h, uint64_t key); void uint64_t_Hashmap_Impl_Rehash( uint64_t_Hashmap* h, size_t newCapacity); void uint64_t_Hashmap_Impl_Grow( uint64_t_Hashmap* h); char uint64_t_Hashmap_Impl_Full( uint64_t_Hashmap* h); char uint64_t_Hashmap_Has( uint64_t_Hashmap* h, uint64_t key); uint64_t uint64_t_Hashmap_Get( uint64_t_Hashmap* h, uint64_t key, uint64_t defaultValue ); uint64_t * uint64_t_Hashmap_GetPtr( uint64_t_Hashmap* h, uint64_t key, uint64_t * defaultValue ); size_t uint64_t_Hashmap_Set( uint64_t_Hashmap* h, uint64_t key, uint64_t value ); size_t uint64_t_Hashmap_SetPtr( uint64_t_Hashmap* h, uint64_t key, uint64_t* value ); void uint64_t_Hashmap_Remove( uint64_t_Hashmap* h, uint64_t key ); void uint64_t_Hashmap_Reserve( uint64_t_Hashmap* h, size_t capacity ); void uint64_t_Hashmap_Clear( uint64_t_Hashmap* h ); void uint64_t_Hashmap_Multi_Get( uint64_t_Hashmap* h, uint64_t key, uint64_t_Array * items ); void uint64_t_Hashmap_Multi_GetPtrs( uint64_t_Hashmap* h, uint64_t key, Containment_Ptr_uint64_t_Array * items ); size_t uint64_t_Hashmap_Multi_Count( uint64_t_Hashmap* h, uint64_t key ); void uint64_t_Hashmap_Multi_Insert( uint64_t_Hashmap* h, uint64_t key, uint64_t value ); void uint64_t_Hashmap_Multi_InsertMany( uint64_t_Hashmap* h, uint64_t key, uint64_t * values, size_t count ); uint64_t_Hashmap_Entry* uint64_t_Hashmap_Multi_FindFirst( uint64_t_Hashmap* h, uint64_t key); uint64_t_Hashmap_Entry* uint64_t_Hashmap_Multi_FindNext( uint64_t_Hashmap* h, uint64_t_Hashmap_Entry* e); void uint64_t_Hashmap_Multi_Remove( uint64_t_Hashmap* h, uint64_t_Hashmap_Entry* e); void uint64_t_Hashmap_Multi_RemoveAll(uint64_t_Hashmap* h, uint64_t key); inline uint64_t_Hashmap uint64_t_Hashmap_Create(void) { uint64_t_Hashmap hashmap; hashmap.hashes = size_t_Array_Create(); hashmap.data = uint64_t_Hashmap_Entry_Array_Create(); return hashmap; } inline void uint64_t_Hashmap_Free( uint64_t_Hashmap* h ) { size_t_Array_Free(&h->hashes); uint64_t_Hashmap_Entry_Array_Free(&h->data); } inline size_t uint64_t_Hashmap_Impl_AddEntry( uint64_t_Hashmap* h, uint64_t key) { uint64_t_Hashmap_Entry e; e.key = key; e.next = ((size_t)(-1)); size_t eIndex = h->data.length; uint64_t_Hashmap_Entry_Array_Append(&h->data, e); return eIndex; } inline void uint64_t_Hashmap_Impl_Erase( uint64_t_Hashmap* h, FindResult* fr) { if (fr->dataPrev == ((size_t)(-1))) h->hashes.data[fr->hashIndex] = h->data.data[fr->dataIndex].next; else h->data.data[fr->dataPrev].next = h->data.data[fr->dataIndex].next; uint64_t_Hashmap_Entry_Array_PopBack(&h->data); if (fr->dataIndex == h->data.length) return; FindResult last = uint64_t_Hashmap_Impl_FindByKey(h, h->data.data[fr->dataIndex].key); if (last.dataPrev == ((size_t)(-1))) h->hashes.data[last.hashIndex] = fr->dataIndex; else h->data.data[last.dataIndex].next = fr->dataIndex; } inline FindResult uint64_t_Hashmap_Impl_FindByKey( uint64_t_Hashmap* h, uint64_t key) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0) return fr; fr.hashIndex = key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (h->data.data[fr.dataIndex].key == key) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr; } inline FindResult uint64_t_Hashmap_Impl_FindByEntry( uint64_t_Hashmap* h, uint64_t_Hashmap_Entry* e) { FindResult fr; fr.hashIndex = ((size_t)(-1)); fr.dataPrev = ((size_t)(-1)); fr.dataIndex = ((size_t)(-1)); if (h->hashes.length == 0 || !e) return fr; fr.hashIndex = e->key % h->hashes.length; fr.dataIndex = h->hashes.data[fr.hashIndex]; while (fr.dataIndex != ((size_t)(-1))) { if (&h->data.data[fr.dataIndex] == e) return fr; fr.dataPrev = fr.dataIndex; fr.dataIndex = h->data.data[fr.dataIndex].next; } return fr;} inline size_t uint64_t_Hashmap_Impl_Make( uint64_t_Hashmap* h, uint64_t key) { FindResult fr = uint64_t_Hashmap_Impl_FindByKey(h, key); size_t index = uint64_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; h->data.data[index].next = fr.dataIndex; return index; } inline void uint64_t_Hashmap_Impl_FindAndErase( uint64_t_Hashmap* h, uint64_t key) { FindResult fr = uint64_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) uint64_t_Hashmap_Impl_Erase(h, &fr); } inline size_t uint64_t_Hashmap_Impl_FindOrFail( uint64_t_Hashmap* h, uint64_t key) { return uint64_t_Hashmap_Impl_FindByKey(h, key).dataIndex; } inline size_t uint64_t_Hashmap_Impl_FindOrMake( uint64_t_Hashmap* h, uint64_t key) { FindResult fr = uint64_t_Hashmap_Impl_FindByKey(h, key); if (fr.dataIndex != ((size_t)(-1))) return fr.dataIndex; size_t index = uint64_t_Hashmap_Impl_AddEntry(h, key); if (fr.dataPrev == ((size_t)(-1))) h->hashes.data[fr.hashIndex] = index; else h->data.data[fr.dataPrev].next = index; return index; } inline void uint64_t_Hashmap_Impl_Rehash( uint64_t_Hashmap* h, size_t newCapacity) { uint64_t_Hashmap nh = uint64_t_Hashmap_Create(); size_t_Array_Resize(&nh.hashes, newCapacity); size_t oldLength = h->data.length; uint64_t_Hashmap_Entry_Array_Reserve(&nh.data, oldLength); for (size_t i = 0; i < newCapacity; i++) nh.hashes.data[i] = ((size_t)(-1)); for (size_t i = 0; i < oldLength; i++) { uint64_t_Hashmap_Entry* e = &h->data.data[i]; uint64_t_Hashmap_Multi_Insert(&nh, e->key, e->value); } memcpy(h, &nh, sizeof(nh)); nh = uint64_t_Hashmap_Create(); } inline void uint64_t_Hashmap_Impl_Grow( uint64_t_Hashmap* h) { size_t newCapacity = 2 * h->data.length + 2 ; uint64_t_Hashmap_Impl_Rehash(h, newCapacity); } inline char uint64_t_Hashmap_Impl_Full( uint64_t_Hashmap* h) { float maxLoadCoefficient = 0.75f; return h->data.length >= maxLoadCoefficient * h->hashes.length ? 1 : 0; } inline char uint64_t_Hashmap_Has( uint64_t_Hashmap* h, uint64_t key) { return uint64_t_Hashmap_Impl_FindOrFail(h, key) != ((size_t)(-1)); } inline uint64_t uint64_t_Hashmap_Get( uint64_t_Hashmap* h, uint64_t key, uint64_t defaultValue ) { size_t index = uint64_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return h->data.data[index].value; } inline uint64_t * uint64_t_Hashmap_GetPtr( uint64_t_Hashmap* h, uint64_t key, uint64_t * defaultValue ) { size_t index = uint64_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return defaultValue; return &h->data.data[index].value; } inline size_t uint64_t_Hashmap_Set( uint64_t_Hashmap* h, uint64_t key, uint64_t value ) { if (h->hashes.length == 0) uint64_t_Hashmap_Impl_Grow(h); size_t index = uint64_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = value; if (uint64_t_Hashmap_Impl_Full(h)) uint64_t_Hashmap_Impl_Grow(h); return index; } inline size_t uint64_t_Hashmap_SetPtr( uint64_t_Hashmap* h, uint64_t key, uint64_t* value ) { if (h->hashes.length == 0) uint64_t_Hashmap_Impl_Grow(h); size_t index = uint64_t_Hashmap_Impl_FindOrMake(h, key); h->data.data[index].value = *value; if (uint64_t_Hashmap_Impl_Full(h)) uint64_t_Hashmap_Impl_Grow(h); return index; } inline void uint64_t_Hashmap_Remove( uint64_t_Hashmap* h, uint64_t key ) { uint64_t_Hashmap_Impl_FindAndErase(h, key); } inline void uint64_t_Hashmap_Reserve( uint64_t_Hashmap* h, size_t capacity ) { uint64_t_Hashmap_Impl_Rehash(h, capacity); } inline void uint64_t_Hashmap_Clear( uint64_t_Hashmap* h ) { size_t_Array_Clear(&h->hashes); uint64_t_Hashmap_Entry_Array_Clear(&h->data); } inline void uint64_t_Hashmap_Multi_Get( uint64_t_Hashmap* h, uint64_t key, uint64_t_Array * items ) { uint64_t_Hashmap_Entry* e = uint64_t_Hashmap_Multi_FindFirst(h, key); while (e) { uint64_t_Array_Append(items, e->value); e = uint64_t_Hashmap_Multi_FindNext(h, e); } } inline void uint64_t_Hashmap_Multi_GetPtrs( uint64_t_Hashmap* h, uint64_t key, Containment_Ptr_uint64_t_Array * items ) { uint64_t_Hashmap_Entry* e = uint64_t_Hashmap_Multi_FindFirst(h, key); while (e) { Containment_Ptr_uint64_t_Array_Append(items, & (e->value) ); e = uint64_t_Hashmap_Multi_FindNext(h, e); } } inline size_t uint64_t_Hashmap_Multi_Count( uint64_t_Hashmap* h, uint64_t key ) { uint64_t_Hashmap_Entry* e = uint64_t_Hashmap_Multi_FindFirst(h, key); size_t c = 0; while (e) { c++; e = uint64_t_Hashmap_Multi_FindNext(h, e); } return c; } inline void uint64_t_Hashmap_Multi_Insert( uint64_t_Hashmap* h, uint64_t key, uint64_t value ) { if (h->hashes.length == 0) uint64_t_Hashmap_Impl_Grow(h); size_t next = uint64_t_Hashmap_Impl_Make(h, key); h->data.data[next].value = value; if (uint64_t_Hashmap_Impl_Full(h)) uint64_t_Hashmap_Impl_Grow(h); } inline void uint64_t_Hashmap_Multi_InsertMany( uint64_t_Hashmap* h, uint64_t key, uint64_t * values, size_t count ) { for (size_t i = 0; i < count; i++) { uint64_t_Hashmap_Multi_Insert(h, key, values[i]); } } inline uint64_t_Hashmap_Entry* uint64_t_Hashmap_Multi_FindFirst( uint64_t_Hashmap* h, uint64_t key) { size_t index = uint64_t_Hashmap_Impl_FindOrFail(h, key); if (index == ((size_t)(-1))) return NULL; return &h->data.data[index]; } inline uint64_t_Hashmap_Entry* uint64_t_Hashmap_Multi_FindNext( uint64_t_Hashmap* h, uint64_t_Hashmap_Entry* e) { if (!e) return NULL; size_t index = e->next; while (index != ((size_t)(-1))) { if (h->data.data[index].key == e->key) return &h->data.data[index]; index = h->data.data[index].next; } return NULL; } inline void uint64_t_Hashmap_Multi_Remove( uint64_t_Hashmap* h, uint64_t_Hashmap_Entry* e) { FindResult fr = uint64_t_Hashmap_Impl_FindByEntry(h, e); if (fr.dataIndex != ((size_t)(-1))) uint64_t_Hashmap_Impl_Erase(h, &fr); } inline void uint64_t_Hashmap_Multi_RemoveAll(uint64_t_Hashmap* h, uint64_t key) { while (uint64_t_Hashmap_Has(h, key)) uint64_t_Hashmap_Remove(h, key); }
inline uint64_t ContainmentHashCustomSeed(const void* key, int32_t len, uint64_t seed)
{
 const uint32_t m = 0x5bd1e995;
 const int32_t r = 24;
 uint32_t h1 = ((uint32_t)(seed)) ^ len;
 uint32_t h2 = (uint32_t)(seed >> 32);
 const uint32_t* data = (const uint32_t*)key;
 while (len >= 8)
 {
  uint32_t k1 = *data++;
  k1 *= m;
  k1 ^= k1 >> r;
  k1 *= m;
  h1 *= m;
  h1 ^= k1;
  len -= 4;
  uint32_t k2 = *data++;
  k2 *= m;
  k2 ^= k2 >> r;
  k2 *= m;
  h2 *= m;
  h2 ^= k2;
  len -= 4;
 }
 if (len >= 4)
 {
  uint32_t k1 = *data++;
  k1 *= m;
  k1 ^= k1 >> r;
  k1 *= m;
  h1 *= m;
  h1 ^= k1;
  len -= 4;
 }
 switch (len)
 {
 case 3: h2 ^= ((uint8_t*)data)[2] << 16;
 case 2: h2 ^= ((uint8_t*)data)[1] << 8;
 case 1: h2 ^= ((uint8_t*)data)[0];
  h2 *= m;
 };
 h1 ^= h2 >> 18;
 h1 *= m;
 h2 ^= h1 >> 22;
 h2 *= m;
 h1 ^= h2 >> 17;
 h1 *= m;
 h2 ^= h1 >> 19;
 h2 *= m;
 uint64_t h = h1;
 h = (h << 32) | h2;
 return h;
}
inline uint64_t ContainmentHash(const void* key, int32_t len)
{
 return ContainmentHashCustomSeed(key, len, 0x9747b28c);
}
inline uint64_t ContainmentHashStringCustomSeed(const char* key, uint64_t seed)
{
 return ContainmentHashCustomSeed(key, (int32_t) strlen(key), seed);
}
inline uint64_t ContainmentHashString(const char* key)
{
 return ContainmentHash(key, (int32_t) strlen(key));
}
inline uint64_t hash_str(const char* key)
{
 return ContainmentHashString(key);
}
