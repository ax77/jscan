typedef enum { False = 0, True = 1 } Bool;
enum { List_InvalidIndex = -1 };
enum { List_DefaultLength = 4 };
enum { List_Nullptr = (int)NULL };
void Test_delete(Test *p) {
    _public_List_double_delete_deep(p->darr);
    free(p);
}
typedef int _public_List_Test_SizeType;typedef Test *_public_List_Test_ItemPtr;typedef void (*_public_List_Test_Destructor)(_public_List_Test_ItemPtr pItem); typedef struct _public_List_Test{ _public_List_Test_SizeType size; _public_List_Test_SizeType capacity; Test **data;} _public_List_Test; static Bool _private_List_Test_indexValid(_public_List_Test *list, _public_List_Test_SizeType index) { return ((0 <= index) && (index < list->size));}static Bool _private_List_Test_newIndexValid(_public_List_Test *list, _public_List_Test_SizeType index) { return ((0 <= index) && (index <= list->size));}static void _private_List_Test_deleteItems(_public_List_Test *list, _public_List_Test_SizeType begin, _public_List_Test_SizeType end) { _public_List_Test_Destructor destructor = (_public_List_Test_Destructor)Test_delete; if (destructor != (_public_List_Test_Destructor)List_Nullptr) { for (; begin < end; ++begin) { destructor(list->data[begin]); } }}static void _private_List_Test_swapItems(_public_List_Test *list, _public_List_Test_SizeType index0, _public_List_Test_SizeType index1) { _public_List_Test_ItemPtr tmp = list->data[index0]; list->data[index0] = list->data[index1]; list->data[index1] = tmp;} static _public_List_Test* _public_List_Test_new() { _public_List_Test *list = (_public_List_Test*)malloc(sizeof(_public_List_Test)); list->capacity = 0; list->size = 0; list->data = (_public_List_Test_ItemPtr*)List_Nullptr; return list;}static void _public_List_Test_delete_shallow(_public_List_Test *list) { free(list->data); free(list);}static void _public_List_Test_delete_deep(_public_List_Test *list) { _private_List_Test_deleteItems(list, 0, list->size); _public_List_Test_delete_shallow(list);}static void _public_List_Test_reserve(_public_List_Test *list, _public_List_Test_SizeType newCapacity) { if (newCapacity < list->capacity) { return; } list->data = (_public_List_Test_ItemPtr*)realloc(list->data, newCapacity * sizeof(_public_List_Test_ItemPtr)); list->capacity = newCapacity;}static void _public_List_Test_resize_shallow(_public_List_Test *list, _public_List_Test_SizeType newSize) { _public_List_Test_reserve(list, newSize); list->size = newSize;}static void _public_List_Test_resize_deep(_public_List_Test *list, _public_List_Test_SizeType newSize) { _private_List_Test_deleteItems(list, newSize, list->size); _public_List_Test_resize_shallow(list, newSize);}static Bool _public_List_Test_empty(_public_List_Test *list) { return (list->size == 0);}static _public_List_Test_ItemPtr _public_List_Test_get(_public_List_Test *list, _public_List_Test_SizeType index) { if (!_private_List_Test_indexValid(list, index)) { return (_public_List_Test_ItemPtr)List_Nullptr; } return list->data[index];}static Bool _public_List_Test_set(_public_List_Test *list, _public_List_Test_ItemPtr pItem, _public_List_Test_SizeType index) { if (!_private_List_Test_indexValid(list, index)) { return False; } list->data[index] = pItem; return True;}static _public_List_Test_SizeType _public_List_Test_find(_public_List_Test *list, _public_List_Test_ItemPtr pItem) { _public_List_Test_SizeType i; for (i = 0; i < list->size; ++i) { if (list->data[i] == pItem) { return i; } } return List_InvalidIndex;}static void _public_List_Test_pushback(_public_List_Test *list, _public_List_Test_ItemPtr pItem) { if (list->capacity <= 0) { _public_List_Test_reserve(list, List_DefaultLength); } if (list->size == list->capacity) { _public_List_Test_reserve(list, list->size * 2); } list->data[list->size] = pItem; ++list->size;}static Bool _public_List_Test_insert(_public_List_Test *list, _public_List_Test_ItemPtr pItem, _public_List_Test_SizeType index) { _public_List_Test_SizeType i; if (!_private_List_Test_newIndexValid(list, index)) { return False; } if (list->size == list->capacity) { _public_List_Test_reserve(list, list->capacity * 2); } for (i = list->size; i > index; --i) { list->data[i] = list->data[i - 1]; } list->data[index] = pItem; ++list->size; return True;}static void _public_List_Test_clear_shallow(_public_List_Test *list) { list->size = 0;}static void _public_List_Test_clear_deep(_public_List_Test *list) { _public_List_Test_resize_deep(list, 0);}static void _public_List_Test_copy_shallow(_public_List_Test *srcList, _public_List_Test *dstList) { _public_List_Test_resize_shallow(dstList, srcList->size); dstList->size = srcList->size; memcpy(dstList->data, srcList->data, srcList->size * sizeof(_public_List_Test_ItemPtr));}static void _public_List_Test_remove_shallow(_public_List_Test *list, _public_List_Test_SizeType index) { if (!_private_List_Test_indexValid(list, index)) { return; } list->data[index] = list->data[list->size - 1]; --list->size;}static void _public_List_Test_merge_shallow(_public_List_Test *listA, _public_List_Test *listB) { _public_List_Test_resize_shallow(listA, listA->size + listB->size); memcpy(listA->data + listA->size, listB->data, sizeof(_public_List_Test_ItemPtr) * listB->size);}static void _public_List_Test_reverse(_public_List_Test *list) { _public_List_Test_SizeType i, j; for (i = 0, j = list->size - 1; i < j; ++i, --j) { _private_List_Test_swapItems(list, i, j); }}static void _public_List_Test_shuffle(_public_List_Test *list) { _public_List_Test_SizeType i; for (i = list->size; i > 1; --i) { _private_List_Test_swapItems(list, (i - 1), (rand() % i)); }}
void f(Test *test) {
    Test *p;
    _public_List_Test_ItemPtr q;
    double *d = (double*)malloc(sizeof(double));
    _public_List_Test *arr = _public_List_Test_new();
    *d = 1024;
    _public_List_double_pushback(test->darr, d);
    _public_List_Test_pushback(arr, test);
    p = _public_List_Test_get(arr, 0);
    q = p;
    printf("%d, %lf\n", q->i, *_public_List_double_get(test->darr, 0));
    _public_List_Test_delete_deep(arr);
}
